{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#django-idom","title":"Django IDOM \u00b7","text":""},{"location":"#reactjs-for-django-developers","title":"ReactJS for Django Developers.","text":"<p>Django-IDOM connects your Python project to a ReactJS front-end, allowing you to create interactive websites without needing JavaScript!</p> <p>Following ReactJS styling, web elements are combined into reusable \"components\". These components can utilize hooks and events to create infinitely complex web pages.</p> <p>When needed, IDOM can use components directly from NPM. For additional flexibility, components can also be fully developed in JavaScript.</p> <p>Any Python web framework with Websockets can support IDOM. See below for what frameworks are supported out of the box.</p> Supported Frameworks Supported Frameworks (External) <code>Flask</code>, <code>FastAPI</code>, <code>Sanic</code>, <code>Tornado</code> <code>Django</code>, <code>Plotly-Dash</code>, <code>Jupyter</code>"},{"location":"#resources","title":"Resources","text":"<p>Follow the links below to find out more about this project.</p> <ul> <li>Try it Now - Check out IDOM in a Jupyter Notebook.</li> <li>Documentation - Learn how to install, run, and use IDOM.</li> <li>Community Forum - Ask questions, share ideas, and show off projects.</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>Attribution <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p> </p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li><code>use_query</code> will now utilize <code>field.related_name</code> when postprocessing many-to-one relationships</li> </ul>"},{"location":"changelog/#221-2022-01-09","title":"2.2.1 - 2022-01-09","text":""},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Fixed bug where <code>use_query</code> would not recursively fetch many-to-one relationships.</li> <li>IDOM preloader will now print out the exception stack when failing to import a module.</li> </ul>"},{"location":"changelog/#220-2022-12-28","title":"2.2.0 - 2022-12-28","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Add <code>options: QueryOptions</code> parameter to <code>use_query</code> to allow for configuration of this hook.</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>By default, <code>use_query</code> will recursively prefetch all many-to-many or many-to-one relationships to prevent <code>SynchronousOnlyOperation</code> exceptions.</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li><code>django_idom.hooks._fetch_lazy_fields</code> has been deleted. The equivalent replacement is <code>django_idom.utils.django_query_postprocessor</code>.</li> </ul>"},{"location":"changelog/#210-2022-11-01","title":"2.1.0 - 2022-11-01","text":""},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Minimum <code>channels</code> version is now <code>4.0.0</code>.</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Change type hint on <code>view_to_component</code> callable to have <code>request</code> argument be optional.</li> <li>Change type hint on <code>view_to_component</code> to represent it as a decorator with parenthesis (such as <code>@view_to_component(compatibility=True)</code>)</li> </ul>"},{"location":"changelog/#security","title":"Security","text":"<ul> <li>Add note to docs about potential information exposure via <code>view_to_component</code> when using <code>compatibility=True</code>.</li> </ul>"},{"location":"changelog/#201-2022-10-18","title":"2.0.1 - 2022-10-18","text":""},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>Ability to use <code>key=...</code> parameter on all prefabricated components.</li> </ul>"},{"location":"changelog/#200-2022-10-17","title":"2.0.0 - 2022-10-17","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li><code>use_origin</code> hook for returning the browser's <code>location.origin</code>.</li> </ul>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li><code>view_to_component</code> now returns a <code>Callable</code>, instead of directly returning a <code>Component</code>. Check the docs for new usage info.</li> <li><code>use_mutation</code> and <code>use_query</code> will now log any query failures.</li> </ul>"},{"location":"changelog/#fixed_4","title":"Fixed","text":"<ul> <li>Allow <code>use_mutation</code> to have <code>refetch=None</code>, as the docs suggest is possible.</li> <li><code>use_query</code> will now prefetch all fields to prevent <code>SynchronousOnlyOperation</code> exceptions.</li> <li><code>view_to_component</code>, <code>django_css</code>, and <code>django_js</code> type hints will now display like normal functions.</li> <li>IDOM preloader no longer attempts to parse commented out IDOM components.</li> <li>Tests are now fully functional on Windows</li> </ul>"},{"location":"changelog/#120-2022-09-19","title":"1.2.0 - 2022-09-19","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li><code>auth_required</code> decorator to prevent your components from rendering to unauthenticated users.</li> <li><code>use_query</code> hook for fetching database values.</li> <li><code>use_mutation</code> hook for modifying database values.</li> <li><code>view_to_component</code> utility to convert legacy Django views to IDOM components.</li> </ul>"},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>Bumped the minimum IDOM version to 0.40.2</li> <li>Testing suite now uses <code>playwright</code> instead of <code>selenium</code></li> </ul>"},{"location":"changelog/#fixed_5","title":"Fixed","text":"<ul> <li>IDOM preloader is no longer sensitive to whitespace within template tags.</li> </ul>"},{"location":"changelog/#110-2022-07-01","title":"1.1.0 - 2022-07-01","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li><code>django_css</code> and <code>django_js</code> components to defer loading CSS &amp; JS files until needed.</li> </ul>"},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>Bumped the minimum IDOM version to 0.39.0</li> </ul>"},{"location":"changelog/#100-2022-05-22","title":"1.0.0 - 2022-05-22","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Django-specific hooks! <code>use_websocket</code>, <code>use_scope</code>, and <code>use_location</code> are now available within the <code>django_idom.hooks</code> module.</li> <li>Documentation has been placed into a formal docs webpage.</li> <li>Logging for when a component fails to import, or if no components were found within Django.</li> </ul>"},{"location":"changelog/#changed_5","title":"Changed","text":"<ul> <li><code>idom_component</code> template tag has been renamed to <code>component</code></li> <li>Bumped the minimum IDOM version to 0.38.0</li> </ul>"},{"location":"changelog/#removed_1","title":"Removed","text":"<ul> <li><code>websocket</code> parameter for components has been removed. Functionally, it is replaced with <code>django_idom.hooks.use_websocket</code>.</li> </ul>"},{"location":"changelog/#005-2022-04-04","title":"0.0.5 - 2022-04-04","text":""},{"location":"changelog/#changed_6","title":"Changed","text":"<ul> <li>Bumped the minimum IDOM version to 0.37.2</li> </ul>"},{"location":"changelog/#fixed_6","title":"Fixed","text":"<ul> <li>ModuleNotFoundError: No module named <code>idom.core.proto</code> caused by IDOM 0.37.2</li> </ul>"},{"location":"changelog/#004-2022-03-05","title":"0.0.4 - 2022-03-05","text":""},{"location":"changelog/#changed_7","title":"Changed","text":"<ul> <li>Bumped the minimum IDOM version to 0.37.1</li> </ul>"},{"location":"changelog/#003-2022-02-19","title":"0.0.3 - 2022-02-19","text":""},{"location":"changelog/#changed_8","title":"Changed","text":"<ul> <li>Bumped the minimum IDOM version to 0.36.3</li> </ul>"},{"location":"changelog/#002-2022-01-30","title":"0.0.2 - 2022-01-30","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>Ability to declare the HTML class of the top-level component <code>div</code></li> <li><code>name = ...</code> parameter to IDOM HTTP paths for use with <code>django.urls.reverse()</code></li> <li>Cache versioning to automatically invalidate old web module files from the cache back-end</li> <li>Automatic pre-population of the IDOM component registry</li> <li>Type hinting for <code>IdomWebsocket</code></li> </ul>"},{"location":"changelog/#changed_9","title":"Changed","text":"<ul> <li>Fetching web modules from disk and/or cache is now fully async</li> <li>Static files are now contained within a <code>django_idom/</code> parent folder</li> <li>Upgraded IDOM to version <code>0.36.0</code></li> <li>Minimum Django version required is now <code>4.0</code></li> <li>Minimum Python version required is now <code>3.8</code></li> </ul>"},{"location":"changelog/#removed_2","title":"Removed","text":"<ul> <li><code>IDOM_WEB_MODULES_PATH</code> has been replaced with Django <code>include(...)</code></li> <li><code>IDOM_WS_MAX_RECONNECT_DELAY</code> has been renamed to <code>IDOM_WS_MAX_RECONNECT_TIMEOUT</code></li> <li><code>idom_web_modules</code> cache back-end has been renamed to <code>idom</code></li> </ul>"},{"location":"changelog/#fixed_7","title":"Fixed","text":"<ul> <li>Increase test timeout values to prevent false positives</li> <li>Windows compatibility for building Django-IDOM</li> </ul>"},{"location":"changelog/#security_1","title":"Security","text":"<ul> <li>Fixed potential directory traversal attack on the IDOM web modules URL</li> </ul>"},{"location":"changelog/#001-2021-08-18","title":"0.0.1 - 2021-08-18","text":""},{"location":"changelog/#added_6","title":"Added","text":"<ul> <li>Support for IDOM within the Django</li> </ul>"},{"location":"contribute/code/","title":"Code","text":"Looking to contribute features that are not Django specific? <p>Everything within the <code>django-idom</code> repository must be specific to Django integration. Check out the IDOM Core documentation to contribute general features such as: components, hooks, events, and more.</p> <p>If you plan to make code changes to this repository, you will need to install the following dependencies first:</p> <ul> <li>Python 3.8+</li> <li>Git</li> <li>NPM for installing and managing Javascript</li> </ul> <p>Once done, you should clone this repository:</p> <pre><code>git clone https://github.com/idom-team/django-idom.git\ncd django-idom\n</code></pre> <p>Then, by running the command below you can:</p> <ul> <li>Install an editable version of the Python code</li> <li>Download, build, and install Javascript dependencies</li> </ul> <pre><code>pip install -e . -r requirements.txt\n</code></pre> <p>Finally, to verify that everything is working properly, you can manually run the development webserver.</p> <pre><code>cd tests\npython manage.py runserver\n</code></pre> <p>Navigate to <code>http://127.0.0.1:8000</code> to see if the tests are rendering correctly.</p>"},{"location":"contribute/docs/","title":"Docs","text":"<p>If you plan to make changes to this documentation, you will need to install the following dependencies first:</p> <ul> <li>Python 3.8+</li> <li>Git</li> </ul> <p>Once done, you should clone this repository:</p> <pre><code>git clone https://github.com/idom-team/django-idom.git\ncd django-idom\n</code></pre> <p>Then, by running the command below you can:</p> <ul> <li>Install an editable version of the documentation</li> <li>Self-host a test server for the documentation</li> </ul> <pre><code>pip install -r ./requirements/build-docs.txt --upgrade\n</code></pre> <p>Finally, to verify that everything is working properly, you can manually run the docs preview webserver.</p> <pre><code>mkdocs serve\n</code></pre> <p>Navigate to <code>http://127.0.0.1:8000</code> to view a preview of the documentation.</p>"},{"location":"contribute/running-tests/","title":"Running Tests","text":"<p>This repository uses Nox to run tests. For a full test of available scripts run <code>nox -l</code>.</p> <p>If you plan to run tests, you will need to install the following dependencies first:</p> <ul> <li>Python 3.8+</li> <li>Git</li> </ul> <p>Once done, you should clone this repository:</p> <pre><code>git clone https://github.com/idom-team/django-idom.git\ncd django-idom\npip install -r ./requirements/test-run.txt --upgrade\n</code></pre> <p>Then, by running the command below you can run the full test suite:</p> <pre><code>nox -s test\n</code></pre> <p>Or, if you want to run the tests in the foreground:</p> <pre><code>nox -s test -- --headed\n</code></pre>"},{"location":"features/components/","title":"Components","text":"Summary <p>Prefabricated components can be used within your <code>components.py</code> to help simplify development.</p>"},{"location":"features/components/#view-to-component","title":"View To Component","text":"<p>Convert any Django view into a IDOM component by using this decorator. Compatible with Function Based Views and Class Based Views. Views can be sync or async.</p> components.py <pre><code>from idom import component, html\nfrom django.http import HttpResponse\nfrom django_idom.components import view_to_component\n\n@view_to_component\ndef hello_world_view(request):\n    return HttpResponse(\"Hello World!\")\n\n@component\ndef my_component():\n    return html.div(\n        hello_world_view(),\n    )\n</code></pre> See Interface <p>Parameters</p> Name Type Description Default <code>view</code> <code>Callable | View</code> The view function or class to convert. N/A <code>compatibility</code> <code>bool</code> If True, the component will be rendered in an iframe. When using compatibility mode <code>tranforms</code>, <code>strict_parsing</code>, <code>request</code>, <code>args</code>, and <code>kwargs</code> arguments will be ignored. <code>False</code> <code>transforms</code> <code>Sequence[Callable[[VdomDict], Any]]</code> A list of functions that transforms the newly generated VDOM. The functions will be called on each VDOM node. <code>tuple</code> <code>strict_parsing</code> <code>bool</code> If True, an exception will be generated if the HTML does not perfectly adhere to HTML5. <code>True</code> <p>Returns</p> Type Description <code>_ViewComponentConstructor</code> A function that takes <code>request, *args, key, **kwargs</code> and returns an IDOM component. All parameters are directly provided to your view, besides <code>key</code> which is used by IDOM. Potential information exposure when using <code>compatibility = True</code> <p>When using <code>compatibility</code> mode, IDOM automatically exposes a URL to your view.</p> <p>It is your responsibility to ensure privileged information is not leaked via this method.</p> <p>This can be done via directly writing conditionals into your view, or by adding decorators such as <code>user_passes_test</code> to your views prior to using <code>view_to_component</code>.</p> Function Based ViewClass Based View <pre><code>...\n\n@view_to_component(compatibility=True)\n@user_passes_test(lambda u: u.is_superuser)\ndef example_view(request):\n    ...\n</code></pre> <pre><code>...\n\n@view_to_component(compatibility=True)\n@method_decorator(user_passes_test(lambda u: u.is_superuser), name=\"dispatch\")\nclass ExampleView(TemplateView):\n    ...\n</code></pre> Existing limitations <p>There are currently several limitations of using <code>view_to_component</code> that may be resolved in a future version of <code>django_idom</code>.</p> <ul> <li>Requires manual intervention to change request methods beyond <code>GET</code>.</li> <li>IDOM events cannot conveniently be attached to converted view HTML.</li> <li>Does not currently load any HTML contained with a <code>&lt;head&gt;</code> tag</li> <li>Has no option to automatically intercept local anchor link (such as <code>&lt;a href='example/'&gt;&lt;/a&gt;</code>) click events</li> </ul> <p>Please note these limitations do not exist when using <code>compatibility</code> mode.</p> How do I use this for Class Based Views? <p>You can simply pass your Class Based View directly into <code>view_to_component</code>.</p> components.py <pre><code>from idom import component, html\nfrom django.http import HttpResponse\nfrom django.views import View\nfrom django_idom.components import view_to_component\n\n@view_to_component\nclass HelloWorldView(View):\n    def get(self, request):\n        return HttpResponse(\"Hello World!\")\n\n@component\ndef my_component():\n    return html.div(\n        HelloWorldView(),\n    )\n</code></pre> How do I transform views from external libraries? <p>In order to convert external views, you can utilize <code>view_to_component</code> as a function, rather than a decorator.</p> components.py <pre><code>from idom import component, html\nfrom django.http import HttpResponse\nfrom django_idom.components import view_to_component\nfrom some_library.views import example_view\n\nexample_vtc = view_to_component(example_view)\n\n@component\ndef my_component():\n    return html.div(\n        example_vtc(),\n    )\n</code></pre> How do I provide <code>request</code>, <code>args</code>, and <code>kwargs</code> to a view? <p><code>Request</code></p> <p>You can use the <code>request</code> parameter to provide the view a custom request object.</p> components.py <pre><code>from idom import component, html\nfrom django.http import HttpResponse, HttpRequest\nfrom django_idom.components import view_to_component\n\nexample_request = HttpRequest()\nexample_request.method = \"PUT\"\n\n@view_to_component\ndef hello_world_view(request):\n    return HttpResponse(f\"Hello World! {request.method}\")\n\n@component\ndef my_component():\n    return html.div(\n        hello_world_view(\n            example_request,\n        ),\n    )\n</code></pre> <p><code>args</code> and <code>kwargs</code></p> <p>You can use the <code>args</code> and <code>kwargs</code> parameters to provide positional and keyworded arguments to a view.</p> components.py <pre><code>from idom import component, html\nfrom django.http import HttpResponse\nfrom django_idom.components import view_to_component\n\n@view_to_component\ndef hello_world_view(request, arg1, arg2, key1=None, key2=None):\n    return HttpResponse(f\"Hello World! {arg1} {arg2} {key1} {key2}\")\n\n@component\ndef my_component():\n    return html.div(\n        hello_world_view(\n            None, # Your request object (optional)\n            \"value_1\",\n            \"value_2\",\n            key1=\"abc\",\n            key2=\"123\",\n        ),\n    )\n</code></pre> How do I use <code>strict_parseing</code>, <code>compatibility</code>, and <code>transforms</code>? <p><code>strict_parsing</code></p> <p>By default, an exception will be generated if your view's HTML does not perfectly adhere to HTML5.</p> <p>However, there are some circumstances where you may not have control over the original HTML, so you may be unable to fix it. Or you may be relying on non-standard HTML tags such as <code>&lt;my-tag&gt; Hello World &lt;/my-tag&gt;</code>.</p> <p>In these scenarios, you may want to rely on best-fit parsing by setting the <code>strict_parsing</code> parameter to <code>False</code>.</p> components.py <pre><code>from idom import component, html\nfrom django.http import HttpResponse\nfrom django_idom.components import view_to_component\n\n@view_to_component(strict_parsing=False)\ndef hello_world_view(request):\n    return HttpResponse(\"&lt;my-tag&gt; Hello World &lt;/my-tag&gt;\")\n\n@component\ndef my_component():\n    return html.div(\n        hello_world_view(),\n    )\n</code></pre> <p>Note: Best-fit parsing is designed to be similar to how web browsers would handle non-standard or broken HTML.</p> <p><code>compatibility</code></p> <p>For views that rely on HTTP responses other than <code>GET</code> (such as <code>PUT</code>, <code>POST</code>, <code>PATCH</code>, etc), you should consider using compatibility mode to render your view within an iframe.</p> <p>Any view can be rendered within compatibility mode. However, the <code>transforms</code>, <code>strict_parsing</code>, <code>request</code>, <code>args</code>, and <code>kwargs</code> arguments do not apply to compatibility mode.</p> components.py <pre><code>from idom import component, html\nfrom django.http import HttpResponse\nfrom django_idom.components import view_to_component\n\n@view_to_component(compatibility=True)\ndef hello_world_view(request):\n    return HttpResponse(\"Hello World!\")\n\n@component\ndef my_component():\n    return html.div(\n        hello_world_view(),\n    )\n</code></pre> <p>Note: By default the <code>compatibility</code> iframe is unstyled, and thus won't look pretty until you add some CSS.</p> <p><code>transforms</code></p> <p>After your view has been turned into VDOM (python dictionaries), <code>view_to_component</code> will call your <code>transforms</code> functions on every VDOM node.</p> <p>This allows you to modify your view prior to rendering.</p> <p>For example, if you are trying to modify the text of a node with a certain <code>id</code>, you can create a transform like such:</p> components.py <pre><code>from idom import component, html\nfrom django.http import HttpResponse\nfrom django_idom.components import view_to_component\n\ndef example_transform(vdom):\n    attributes = vdom.get(\"attributes\")\n    if attributes and attributes.get(\"id\") == \"hello-world\":\n        vdom[\"children\"][0] = \"Good Bye World!\"\n\n@view_to_component(transforms=[example_transform])\ndef hello_world_view(request):\n    return HttpResponse(\"&lt;div id='hello-world'&gt; Hello World! &lt;div&gt;\")\n\n@component\ndef my_component():\n    return html.div(\n        hello_world_view(),\n    )\n</code></pre>"},{"location":"features/components/#django-css","title":"Django CSS","text":"<p>Allows you to defer loading a CSS stylesheet until a component begins rendering. This stylesheet must be stored within Django's static files.</p> components.py <pre><code>from idom import component, html\nfrom django_idom.components import django_css\n\n@component\ndef my_component():\n    return html.div(\n        django_css(\"css/buttons.css\"),\n        html.button(\"My Button!\"),\n    )\n</code></pre> See Interface <p>Parameters</p> Name Type Description Default <code>static_path</code> <code>str</code> The path to the static file. This path is identical to what you would use on a <code>static</code> template tag. N/A <code>key</code> <code>Key | None</code> A key to uniquely identify this component which is unique amongst a component's immediate siblings <code>None</code> <p>Returns</p> Type Description <code>Component</code> An IDOM component. Should I put <code>django_css</code> at the top of my component? <p>Yes, if the stylesheet contains styling for your component.</p> Can I load static CSS using <code>html.link</code> instead? <p>While you can load stylesheets with <code>html.link</code>, keep in mind that loading this way does not ensure load order. Thus, your stylesheet will be loaded after your component is displayed. This would likely cause unintended visual behavior, so use this at your own discretion.</p> <p>Here's an example on what you should avoid doing for Django static files:</p> <pre><code>from idom import component, html\nfrom django.templatetags.static import static\n\n@component\ndef my_component():\n    return html.div(\n        html.link({\"rel\": \"stylesheet\", \"href\": static(\"css/buttons.css\")}),\n        html.button(\"My Button!\"),\n    )\n</code></pre> How do I load external CSS? <p><code>django_css</code> can only be used with local static files.</p> <p>For external CSS, substitute <code>django_css</code> with <code>html.link</code>.</p> <pre><code>from idom import component, html\n\n@component\ndef my_component():\n    return html.div(\n        html.link({\"rel\": \"stylesheet\", \"href\": \"https://example.com/external-styles.css\"}),\n        html.button(\"My Button!\"),\n    )\n</code></pre> Why not load my CSS in <code>&lt;head&gt;</code>? <p>Traditionally, stylesheets are loaded in your <code>&lt;head&gt;</code> using the <code>{% load static %}</code> template tag.</p> <p>To help improve webpage load times, you can use the <code>django_css</code> component to defer loading your stylesheet until it is needed.</p>"},{"location":"features/components/#django-js","title":"Django JS","text":"<p>Allows you to defer loading JavaScript until a component begins rendering. This JavaScript must be stored within Django's static files.</p> components.py <pre><code>from idom import component, html\nfrom django_idom.components import django_js\n\n@component\ndef my_component():\n    return html.div(\n        html.button(\"My Button!\"),\n        django_js(\"js/scripts.js\"),\n    )\n</code></pre> See Interface <p>Parameters</p> Name Type Description Default <code>static_path</code> <code>str</code> The path to the static file. This path is identical to what you would use on a <code>static</code> template tag. N/A <code>key</code> <code>Key | None</code> A key to uniquely identify this component which is unique amongst a component's immediate siblings <code>None</code> <p>Returns</p> Type Description <code>Component</code> An IDOM component. Should I put <code>django_js</code> at the bottom of my component? <p>Yes, if your scripts are reliant on the contents of the component.</p> Can I load static JavaScript using <code>html.script</code> instead? <p>While you can load JavaScript with <code>html.script</code>, keep in mind that loading this way does not ensure load order. Thus, your JavaScript will likely be loaded at an arbitrary time after your component is displayed.</p> <p>Here's an example on what you should avoid doing for Django static files:</p> <pre><code>from idom import component, html\nfrom django.templatetags.static import static\n\n@component\ndef my_component():\n    return html.div(\n        html.script({\"src\": static(\"js/scripts.js\")}),\n        html.button(\"My Button!\"),\n    )\n</code></pre> How do I load external JS? <p><code>django_js</code> can only be used with local static files.</p> <p>For external JavaScript, substitute <code>django_js</code> with <code>html.script</code>.</p> <pre><code>from idom import component, html\n\n@component\ndef my_component():\n    return html.div(\n        html.script({\"src\": \"https://example.com/external-scripts.js\"}),\n        html.button(\"My Button!\"),\n    )\n</code></pre> Why not load my JS in <code>&lt;head&gt;</code>? <p>Traditionally, JavaScript is loaded in your <code>&lt;head&gt;</code> using the <code>{% load static %}</code> template tag.</p> <p>To help improve webpage load times, you can use the <code>django_js</code> component to defer loading your JavaScript until it is needed.</p>"},{"location":"features/decorators/","title":"Decorators","text":"Summary <p>Decorator utilities can be used within your <code>components.py</code> to help simplify development.</p>"},{"location":"features/decorators/#auth-required","title":"Auth Required","text":"<p>You can limit access to a component to users with a specific <code>auth_attribute</code> by using this decorator.</p> <p>By default, this decorator checks if the user is logged in, and his/her account has not been deactivated.</p> <p>This decorator is commonly used to selectively render a component only if a user <code>is_staff</code> or <code>is_superuser</code>.</p> <p>This decorator can be used with or without parentheses.</p> components.py <pre><code>from django_idom.decorators import auth_required\nfrom django_idom.hooks import use_websocket\nfrom idom import component, html\n\n@component\n@auth_required\ndef my_component():\n    return html.div(\"I am logged in!\")\n</code></pre> See Interface <p>Parameters</p> Name Type Description Default <code>auth_attribute</code> <code>str</code> The value to check within the user object. This is checked in the form of <code>UserModel.&lt;auth_attribute&gt;</code>. <code>\"is_active\"</code> <code>fallback</code> <code>ComponentType</code>, <code>VdomDict</code>, <code>None</code> The <code>component</code> or <code>idom.html</code> snippet to render if the user is not authenticated. <code>None</code> <p>Returns</p> Type Description <code>Component</code> An IDOM component. <code>VdomDict</code> An <code>idom.html</code> snippet. <code>None</code> No component render. How do I render a different component if authentication fails? <p>You can use a component with the <code>fallback</code> argument, as seen below.</p> components.py <pre><code>from django_idom.decorators import auth_required\nfrom idom import component, html\n\n@component\ndef my_component_fallback():\n    return html.div(\"I am NOT logged in!\")\n\n@component\n@auth_required(fallback=my_component_fallback)\ndef my_component():\n    return html.div(\"I am logged in!\")\n</code></pre> How do I render a simple <code>idom.html</code> snippet if authentication fails? <p>You can use a <code>idom.html</code> snippet with the <code>fallback</code> argument, as seen below.</p> components.py <pre><code>from django_idom.decorators import auth_required\nfrom django_idom.hooks import use_websocket\nfrom idom import component, html\n\n@component\n@auth_required(fallback=html.div(\"I am NOT logged in!\"))\ndef my_component():\n    return html.div(\"I am logged in!\")\n</code></pre> How can I check if a user <code>is_staff</code>? <p>You can set the <code>auth_attribute</code> to <code>is_staff</code>, as seen blow.</p> components.py <pre><code>from django_idom.decorators import auth_required\nfrom django_idom.hooks import use_websocket\nfrom idom import component, html\n\n\n@component\n@auth_required(auth_attribute=\"is_staff\")\ndef my_component():\n    return html.div(\"I am logged in!\")\n</code></pre> How can I check for a custom attribute? <p>You will need to be using a custom user model within your Django instance.</p> <p>For example, if your user model has the field <code>is_really_cool</code> ...</p> models.py <pre><code>from django.contrib.auth.models import AbstractBaseUser\n\nclass CustomUserModel(AbstractBaseUser):\n    @property\n    def is_really_cool(self):\n        return True\n</code></pre> <p>... then you would do the following within your decorator:</p> components.py <pre><code>from django_idom.decorators import auth_required\nfrom django_idom.hooks import use_websocket\nfrom idom import component, html\n\n@component\n@auth_required(auth_attribute=\"is_really_cool\")\ndef my_component():\n    return html.div(\"I am logged in!\")\n</code></pre>"},{"location":"features/hooks/","title":"Hooks","text":"Summary <p>Prefabricated hooks can be used within your <code>components.py</code> to help simplify development.</p> Looking for standard ReactJS hooks? <p>Standard ReactJS hooks are contained within <code>idom-team/idom</code>. Since <code>idom</code> is installed by default alongside <code>django-idom</code>, you can import them at any time.</p> <p>Check out the IDOM Core docs to see what hooks are available!</p>"},{"location":"features/hooks/#use-query","title":"Use Query","text":"<p>The <code>use_query</code> hook is used fetch Django ORM queries.</p> <p>The function you provide into this hook must return either a <code>Model</code> or <code>QuerySet</code>.</p> components.pymodels.py <pre><code>from example_project.my_app.models import TodoItem\nfrom idom import component, html\nfrom django_idom.hooks import use_query\n\ndef get_items():\n    return TodoItem.objects.all()\n\n@component\ndef todo_list():\n    item_query = use_query(get_items)\n\n    if item_query.loading:\n        rendered_items = html.h2(\"Loading...\")\n    elif item_query.error:\n        rendered_items = html.h2(\"Error when loading!\")\n    else:\n        rendered_items = html.ul(html.li(item, key=item) for item in item_query.data)\n\n    return rendered_items\n</code></pre> <pre><code>from django.db import models\n\nclass TodoItem(models.Model):\n    text = models.CharField(max_length=255)\n</code></pre> See Interface <p>Parameters</p> Name Type Description Default <code>options</code> <code>QueryOptions | None</code> An optional <code>QueryOptions</code> object that can modify how the query is executed. None <code>query</code> <code>Callable[_Params, _Result | None]</code> A callable that returns a Django <code>Model</code> or <code>QuerySet</code>. N/A <code>*args</code> <code>_Params.args</code> Positional arguments to pass into <code>query</code>. N/A <code>**kwargs</code> <code>_Params.kwargs</code> Keyword arguments to pass into <code>query</code>. N/A <p>Returns</p> Type Description <code>Query[_Result | None]</code> An object containing <code>loading</code>/<code>error</code> states, your <code>data</code> (if the query has successfully executed), and a <code>refetch</code> callable that can be used to re-run the query. How can I provide arguments to my query function? <p><code>*args</code> and <code>**kwargs</code> can be provided to your query function via <code>use_query</code> parameters.</p> components.py <pre><code>from idom import component\nfrom django_idom.hooks import use_query\n\ndef example_query(value: int, other_value: bool = False):\n    ...\n\n@component\ndef my_component():\n    query = use_query(\n        example_query,\n        123,\n        other_value=True,\n    )\n\n    ...\n</code></pre> Why does the example <code>get_items</code> function return <code>TodoItem.objects.all()</code>? <p>This was a technical design decision to based on Apollo's <code>useQuery</code> hook, but ultimately helps avoid Django's <code>SynchronousOnlyOperation</code> exceptions.</p> <p>The <code>use_query</code> hook ensures the provided <code>Model</code> or <code>QuerySet</code> executes all deferred/lazy queries safely prior to reaching your components.</p> Can this hook be used for things other than the Django ORM? <p>By default, automatic recursive fetching of <code>ManyToMany</code> or <code>ForeignKey</code> fields is enabled within the default <code>QueryOptions.postprocessor</code>. This is needed to prevent <code>SynchronousOnlyOperation</code> exceptions when accessing these fields within your IDOM components.</p> <p>However, if you...</p> <ol> <li>Want to use this hook to defer IO intensive tasks to be computed in the background</li> <li>Want to to utilize <code>use_query</code> with a different ORM</li> </ol> <p>... then you can disable all postprocessing behavior by modifying the <code>QueryOptions.postprocessor</code> parameter. In the example below, we will set the <code>postprocessor</code> to <code>None</code> to disable postprocessing behavior.</p> components.py <pre><code>from idom import component\nfrom django_idom.types import QueryOptions\nfrom django_idom.hooks import use_query\n\ndef execute_io_intensive_operation():\n\"\"\"This is an example query function that does something IO intensive.\"\"\"\n    pass\n\n@component\ndef todo_list():\n    query = use_query(\n        QueryOptions(postprocessor=None),\n        execute_io_intensive_operation,\n    )\n\n    if query.loading or query.error:\n        return None\n\n    return str(query.data)\n</code></pre> <p>If you wish to create a custom <code>postprocessor</code>, you will need to create a callable.</p> <p>The first argument of <code>postprocessor</code> must be the query <code>data</code>. All proceeding arguments are optional <code>postprocessor_kwargs</code> (see below). This <code>postprocessor</code> must return the modified <code>data</code>.</p> components.py <pre><code>from idom import component\nfrom django_idom.types import QueryOptions\nfrom django_idom.hooks import use_query\n\ndef my_postprocessor(data, example_kwarg=True):\n    if example_kwarg:\n        return data\n\n    return dict(data)\n\ndef execute_io_intensive_operation():\n\"\"\"This is an example query function that does something IO intensive.\"\"\"\n    pass\n\n@component\ndef todo_list():\n    query = use_query(\n        QueryOptions(\n            postprocessor=my_postprocessor,\n            postprocessor_kwargs={\"example_kwarg\": False},\n        ),\n        execute_io_intensive_operation,\n    )\n\n    if query.loading or query.error:\n        return None\n\n    return str(query.data)\n</code></pre> How can I prevent this hook from recursively fetching <code>ManyToMany</code> fields or <code>ForeignKey</code> relationships? <p>By default, automatic recursive fetching of <code>ManyToMany</code> or <code>ForeignKey</code> fields is enabled within the default <code>QueryOptions.postprocessor</code>. This is needed to prevent <code>SynchronousOnlyOperation</code> exceptions when accessing these fields within your IDOM components.</p> <p>However, if you have deep nested trees of relational data, this may not be a desirable behavior. In these scenarios, you may prefer to manually fetch these relational fields using a second <code>use_query</code> hook.</p> <p>You can disable the prefetching behavior of the default <code>postprocessor</code> (located at <code>django_idom.utils.django_query_postprocessor</code>) via the <code>QueryOptions.postprocessor_kwargs</code> parameter.</p> components.py <pre><code>from example_project.my_app.models import MyModel\nfrom idom import component\nfrom django_idom.types import QueryOptions\nfrom django_idom.hooks import use_query\n\ndef get_model_with_relationships():\n\"\"\"This is an example query function that gets `MyModel` which has a ManyToMany field, and\n    additionally other models that have formed a ForeignKey association to `MyModel`.\n\n    ManyToMany Field: `many_to_many_field`\n    ForeignKey Field: `foreign_key_field_set`\n    \"\"\"\n    return MyModel.objects.get(id=1)\n\n@component\ndef todo_list():\n    query = use_query(\n        QueryOptions(postprocessor_kwargs={\"many_to_many\": False, \"many_to_one\": False}),\n        get_model_with_relationships,\n    )\n\n    if query.loading or query.error:\n        return None\n\n    # By disabling `many_to_many` and `many_to_one`, accessing these fields will now\n    # generate a `SynchronousOnlyOperation` exception\n    return f\"{query.data.many_to_many_field} {query.data.foriegn_key_field_set}\"\n</code></pre> <p>Note: In Django's ORM design, the field name to access foreign keys is always be postfixed with <code>_set</code>.</p> Can I make ORM calls without hooks? <p>Due to Django's ORM design, database queries must be deferred using hooks. Otherwise, you will see a <code>SynchronousOnlyOperation</code> exception.</p> <p>These <code>SynchronousOnlyOperation</code> exceptions may be resolved in a future version of Django containing an asynchronous ORM. However, it is best practice to always perform ORM calls in the background via hooks.</p>"},{"location":"features/hooks/#use-mutation","title":"Use Mutation","text":"<p>The <code>use_mutation</code> hook is used to create, update, or delete Django ORM objects.</p> <p>The function you provide into this hook will have no return value.</p> components.pymodels.py <pre><code>from example_project.my_app.models import TodoItem\nfrom idom import component, html\nfrom django_idom.hooks import use_mutation\n\ndef add_item(text: str):\n    TodoItem(text=text).save()\n\n@component\ndef todo_list():\n    def submit_event(event):\n        if event[\"key\"] == \"Enter\":\n            item_mutation.execute(text=event[\"target\"][\"value\"])\n\n    item_mutation = use_mutation(add_item)\n    if item_mutation.loading:\n        mutation_status = html.h2(\"Adding...\")\n    elif item_mutation.error:\n        mutation_status = html.h2(\"Error when adding!\")\n    else:\n        mutation_status = \"\"\n\n    return html.div(\n        html.label(\"Add an item:\"),\n        html.input({\"type\": \"text\", \"onKeyDown\": submit_event}),\n        mutation_status,\n    )\n</code></pre> <pre><code>from django.db import models\n\nclass TodoItem(models.Model):\n    text = models.CharField(max_length=255)\n</code></pre> See Interface <p>Parameters</p> Name Type Description Default <code>mutate</code> <code>Callable[_Params, bool | None]</code> A callable that performs Django ORM create, update, or delete functionality. If this function returns <code>False</code>, then your <code>refetch</code> function will not be used. N/A <code>refetch</code> <code>Callable[..., Any] | Sequence[Callable[..., Any]] | None</code> A <code>query</code> function (used by the <code>use_query</code> hook) or a sequence of <code>query</code> functions that will be called if the mutation succeeds. This is useful for refetching data after a mutation has been performed. <code>None</code> <p>Returns</p> Type Description <code>Mutation[_Params]</code> An object containing <code>loading</code>/<code>error</code> states, a <code>reset</code> callable that will set <code>loading</code>/<code>error</code> states to defaults, and a <code>execute</code> callable that will run the query. How can I provide arguments to my mutation function? <p><code>*args</code> and <code>**kwargs</code> can be provided to your mutation function via <code>mutation.execute</code> parameters.</p> components.py <pre><code>from idom import component\nfrom django_idom.hooks import use_mutation\n\ndef example_mutation(value: int, other_value: bool = False):\n    ...\n\n@component\ndef my_component():\n    mutation = use_mutation(example_mutation)\n\n    mutation.execute(123, other_value=True)\n\n    ...\n</code></pre> Can <code>use_mutation</code> trigger a refetch of <code>use_query</code>? <p>Yes, <code>use_mutation</code> can queue a refetch of a <code>use_query</code> via the <code>refetch=...</code> argument.</p> <p>The example below is a merge of the <code>use_query</code> and <code>use_mutation</code> examples above with the addition of a <code>refetch</code> argument on <code>use_mutation</code>.</p> <p>Please note that any <code>use_query</code> hooks that use <code>get_items</code> will be refetched upon a successful mutation.</p> components.pymodels.py <pre><code>from example_project.my_app.models import TodoItem\nfrom idom import component, html\nfrom django_idom.hooks import use_mutation\n\ndef get_items():\n    return TodoItem.objects.all()\n\ndef add_item(text: str):\n    TodoItem(text=text).save()\n\n@component\ndef todo_list():\n    item_query = use_query(get_items)\n    item_mutation = use_mutation(add_item, refetch=get_items)\n\n    def submit_event(event):\n        if event[\"key\"] == \"Enter\":\n            item_mutation.execute(text=event[\"target\"][\"value\"])\n\n    # Handle all possible query states\n    if item_query.loading:\n        rendered_items = html.h2(\"Loading...\")\n    elif item_query.error:\n        rendered_items = html.h2(\"Error when loading!\")\n    else:\n        rendered_items = html.ul(html.li(item, key=item) for item in item_query.data)\n\n    # Handle all possible mutation states\n    if item_mutation.loading:\n        mutation_status = html.h2(\"Adding...\")\n    elif item_mutation.error:\n        mutation_status = html.h2(\"Error when adding!\")\n    else:\n        mutation_status = \"\"\n\n    return html.div(\n        html.label(\"Add an item:\"),\n        html.input({\"type\": \"text\", \"onKeyDown\": submit_event}),\n        mutation_status,\n        rendered_items,\n    )\n</code></pre> <pre><code>from django.db import models\n\nclass TodoItem(models.Model):\n    text = models.CharField(max_length=255)\n</code></pre> Can I make a failed <code>use_mutation</code> try again? <p>Yes, a <code>use_mutation</code> can be re-performed by calling <code>reset()</code> on your <code>use_mutation</code> instance.</p> <p>For example, take a look at <code>reset_event</code> below.</p> components.pymodels.py <pre><code>from example_project.my_app.models import TodoItem\nfrom idom import component, html\nfrom django_idom.hooks import use_mutation\n\ndef add_item(text: str):\n    TodoItem(text=text).save()\n\n@component\ndef todo_list():\n    item_mutation = use_mutation(add_item)\n\n    def reset_event(event):\n        item_mutation.reset()\n\n    def submit_event(event):\n        if event[\"key\"] == \"Enter\":\n            item_mutation.execute(text=event[\"target\"][\"value\"])\n\n    if item_mutation.loading:\n        mutation_status = html.h2(\"Adding...\")\n    elif item_mutation.error:\n        mutation_status = html.button({\"onClick\": reset_event}, \"Error: Try again!\")\n    else:\n        mutation_status = \"\"\n\n    return html.div(\n        html.label(\"Add an item:\"),\n        html.input({\"type\": \"text\", \"onKeyDown\": submit_event}),\n        mutation_status,\n    )\n</code></pre> <pre><code>from django.db import models\n\nclass TodoItem(models.Model):\n    text = models.CharField(max_length=255)\n</code></pre> Can I make ORM calls without hooks? <p>Due to Django's ORM design, database queries must be deferred using hooks. Otherwise, you will see a <code>SynchronousOnlyOperation</code> exception.</p> <p>These <code>SynchronousOnlyOperation</code> exceptions may be resolved in a future version of Django containing an asynchronous ORM. However, it is best practice to always perform ORM calls in the background via hooks.</p>"},{"location":"features/hooks/#use-websocket","title":"Use Websocket","text":"<p>You can fetch the Django Channels websocket at any time by using <code>use_websocket</code>.</p> components.py <pre><code>from idom import component, html\nfrom django_idom.hooks import use_websocket\n\n@component\ndef my_component():\n    my_websocket = use_websocket()\n    return html.div(my_websocket)\n</code></pre> See Interface <p>Parameters</p> <p><code>None</code></p> <p>Returns</p> Type Description <code>IdomWebsocket</code> The component's websocket."},{"location":"features/hooks/#use-scope","title":"Use Scope","text":"<p>This is a shortcut that returns the Websocket's <code>scope</code>.</p> components.py <pre><code>from idom import component, html\nfrom django_idom.hooks import use_scope\n\n@component\ndef my_component():\n    my_scope = use_scope()\n    return html.div(my_scope)\n</code></pre> See Interface <p>Parameters</p> <p><code>None</code></p> <p>Returns</p> Type Description <code>dict[str, Any]</code> The websocket's <code>scope</code>."},{"location":"features/hooks/#use-location","title":"Use Location","text":"<p>This is a shortcut that returns the Websocket's <code>path</code>.</p> <p>You can expect this hook to provide strings such as <code>/idom/my_path</code>.</p> components.py <pre><code>from idom import component, html\nfrom django_idom.hooks import use_location\n\n@component\ndef my_component():\n    my_location = use_location()\n    return html.div(my_location)\n</code></pre> See Interface <p>Parameters</p> <p><code>None</code></p> <p>Returns</p> Type Description <code>Location</code> A object containing the current URL's <code>pathname</code> and <code>search</code> query. This hook's behavior will be changed in a future update <p>This hook will be updated to return the browser's currently active path. This change will come in alongside IDOM URL routing support.</p> <p>Check out idom-team/idom-router#2 for more information.</p>"},{"location":"features/hooks/#use-origin","title":"Use Origin","text":"<p>This is a shortcut that returns the Websocket's <code>origin</code>.</p> <p>You can expect this hook to provide strings such as <code>http://example.com</code>.</p> components.py <pre><code>from idom import component, html\nfrom django_idom.hooks import use_origin\n\n@component\ndef my_component():\n    my_origin = use_origin()\n    return html.div(my_origin)\n</code></pre> See Interface <p>Parameters</p> <p><code>None</code></p> <p>Returns</p> Type Description <code>str | None</code> A string containing the browser's current origin, obtained from websocket headers (if available)."},{"location":"features/settings/","title":"Settings","text":"Summary <p>Django-IDOM uses your Django project's <code>settings.py</code> file to modify the behavior of IDOM.</p>"},{"location":"features/settings/#primary-configuration","title":"Primary Configuration","text":"settings.py <pre><code># If \"idom\" cache is not configured, then we will use \"default\" instead\nCACHES = {\n\"idom\": {\"BACKEND\": ...},\n}\n\n# Maximum seconds between two reconnection attempts that would cause the client give up.\n# 0 will disable reconnection.\nIDOM_WS_MAX_RECONNECT_TIMEOUT = 604800\n\n# The URL for IDOM to serve websockets\nIDOM_WEBSOCKET_URL = \"idom/\"\n\n# Dotted path to the default postprocessor function, or `None`\nIDOM_DEFAULT_QUERY_POSTPROCESSOR = \"example_project.utils.my_postprocessor\"\n</code></pre> Do I need to modify my settings? <p>The default configuration of IDOM is adequate for the majority of use cases.</p> <p>You should only consider changing settings when the necessity arises.</p>"},{"location":"features/templatetag/","title":"Template Tag","text":"Summary <p>Template tags can be used within your Django templates such as <code>my-template.html</code> to import IDOM features.</p>"},{"location":"features/templatetag/#component","title":"Component","text":"my-template.html <pre><code>{% load idom %}\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;body&gt;\n{% component \"example_project.my_app.components.hello_world\" recipient=\"World\" %}\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> Do not use context variables for the IDOM component name <p>Our pre-processor relies on the template tag containing a string.</p> <p>Do not use Django template/context variables for the component path. Failure to follow this warning will result in unexpected behavior.</p> <p>For example, do not do the following:</p> my-template.htmlviews.py <pre><code>&lt;!-- This is bad --&gt;\n{% component dont_do_this recipient=\"World\" %}\n\n&lt;!-- This is good --&gt;\n{% component \"example_project.my_app.components.hello_world\" recipient=\"World\" %}\n</code></pre> <pre><code>def example_view():\n    context_vars = {\"dont_do_this\": \"example_project.my_app.components.hello_world\"}\n    return render(request, \"my-template.html\", context_vars)\n</code></pre> Reserved keyword arguments: <code>class</code> and <code>key</code> <p>For this template tag, there are two reserved keyword arguments: <code>class</code> and <code>key</code></p> <ul> <li><code>class</code> allows you to apply a HTML class to the top-level component div. This is useful for styling purposes.</li> <li><code>key</code> allows you to force the component to use a specific key value. You typically won't need to set this.</li> </ul> my-template.html <pre><code>...\n{% component \"example.components.my_component\" class=\"my-html-class\" key=123 %}\n...\n</code></pre> See Interface <p>Parameters</p> Name Type Description Default <code>dotted_path</code> <code>str</code> The dotted path to the component to render. N/A <code>**kwargs</code> <code>Any</code> The keyword arguments to pass to the component. N/A <p>Returns</p> Type Description <code>Component</code> An IDOM component. Can I use multiple components on one page? <p>You can add as many components to a webpage as needed by using the template tag multiple times. Retrofitting legacy sites to use IDOM will typically involve many components on one page.</p> my-template.html <pre><code>{% load idom %}\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;body&gt;\n{% component \"example_project.my_app.components.hello_world\" recipient=\"World\" %}\n{% component \"example_project.my_app_2.components.class_component\" class=\"bold small-font\" %}\n    &lt;div&gt;{% component \"example_project.my_app_3.components.simple_component\" %}&lt;/div&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>But keep in mind, in scenarios where you are trying to create a Single Page Application (SPA) within Django, you will only have one central component within your <code>&lt;body&gt;</code> tag.</p> <p>Additionally, the components in the example above will not be able to interact with each other, except through database queries.</p> Can I use positional arguments instead of keyword arguments? <p>You can only pass in keyword arguments within the template tag. Due to technical limitations, positional arguments are not supported at this time.</p> What is a \"template tag\"? <p>You can think of template tags as Django's way of allowing you to run Python code within your HTML. Django-IDOM uses a <code>{% component ... %}</code> template tag to perform it's magic.</p> <p>Keep in mind, in order to use the <code>{% component ... %}</code> tag, you will need to first call <code>{% load idom %}</code> to gain access to it.</p> my-template.html <pre><code>{% load idom %}\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;body&gt;\n{% component \"example_project.my_app.components.hello_world\" recipient=\"World\" %}\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"getting-started/choose-django-app/","title":"2. Choose a Django App","text":"Summary <p>Set up a Django Project with at least one app.</p> <p>If you have reached this point, you should have already installed Django-IDOM through the previous steps.</p> <p>You will now need to pick at least one Django app to start using Django-IDOM on.</p> <p>For the examples within this section, we will assume you have placed the files generated by <code>startapp</code> directly into your Django project folder. This is common for small projects.</p> How do I organize my Django project for IDOM? <p>Django-IDOM has no project structure requirements. Organize everything as you wish, just like any Django project.</p>"},{"location":"getting-started/create-component/","title":"3. Create a Component","text":"Summary <p>Create a component function using our decorator.</p> <p>You will need a file to define your IDOM components. We recommend creating a <code>components.py</code> file within your chosen Django app to start out. Within this file, we will create a simple <code>hello_world</code> component.</p> components.py <pre><code>from idom import component, html\n\n@component\ndef hello_world(recipient: str):\n    return html.h1(f\"Hello {recipient}!\")\n</code></pre> What should I name my IDOM files and functions? <p>You have full freedom in naming/placement of your files and functions.</p> <p>We recommend creating a <code>components.py</code> for small Django apps. If your app has a lot of components, you should consider breaking them apart into individual modules such as <code>components/navbar.py</code>.</p> <p>Ultimately, components are referenced by Python dotted path in <code>my-template.html</code> (see next step). So, at minimum this path needs to be valid to Python's <code>importlib</code>.</p>"},{"location":"getting-started/installation/","title":"1. Install Django-IDOM","text":"Summary <p>Django-IDOM can be installed from PyPI to an existing Django project with minimal configuration.</p>"},{"location":"getting-started/installation/#step-0-set-up-a-django-project","title":"Step 0: Set up a Django Project","text":"<p>These docs assumes you have already created a Django project, which involves creating and installing at least one Django app. If not, check out this 9 minute YouTube tutorial created by IDG TECHtalk.</p>"},{"location":"getting-started/installation/#step-1-install-from-pypi","title":"Step 1: Install from PyPI","text":"<pre><code>pip install django-idom\n</code></pre>"},{"location":"getting-started/installation/#step-2-configure-settingspy","title":"Step 2: Configure <code>settings.py</code>","text":"<p>In your settings you will need to add <code>django_idom</code> to <code>INSTALLED_APPS</code>.</p> settings.py <pre><code>INSTALLED_APPS = [\n    \"django_idom\",\n    ...\n]\n</code></pre> Enable Django ASGI (Required) <p>Django-IDOM requires ASGI in order to use Websockets.</p> <p>If you have not enabled ASGI on your Django project yet, you will need to install <code>channels[daphne]</code>, add <code>daphne</code> to <code>INSTALLED_APPS</code>, then set your <code>ASGI_APPLICATION</code> variable.</p> <p>Read the Django Channels Docs for more info.</p> settings.py <pre><code>INSTALLED_APPS = [\n    \"daphne\",\n    ...\n]\nASGI_APPLICATION = \"example_project.asgi.application\"\n</code></pre> Configure IDOM settings (Optional) <p>Below are a handful of values you can change within <code>settings.py</code> to modify the behavior of IDOM.</p> <pre><code># If \"idom\" cache is not configured, then we will use \"default\" instead\nCACHES = {\n\"idom\": {\"BACKEND\": ...},\n}\n\n# Maximum seconds between two reconnection attempts that would cause the client give up.\n# 0 will disable reconnection.\nIDOM_WS_MAX_RECONNECT_TIMEOUT = 604800\n\n# The URL for IDOM to serve websockets\nIDOM_WEBSOCKET_URL = \"idom/\"\n\n# Dotted path to the default postprocessor function, or `None`\nIDOM_DEFAULT_QUERY_POSTPROCESSOR = \"example_project.utils.my_postprocessor\"\n</code></pre>"},{"location":"getting-started/installation/#step-3-configure-urlspy","title":"Step 3: Configure <code>urls.py</code>","text":"<p>Add IDOM HTTP paths to your <code>urlpatterns</code>.</p> urls.py <pre><code>from django.urls import include, path\n\nurlpatterns = [\n    path(\"idom/\", include(\"django_idom.http.urls\")),\n    ...\n]\n</code></pre>"},{"location":"getting-started/installation/#step-4-configure-asgipy","title":"Step 4: Configure <code>asgi.py</code>","text":"<p>Register IDOM's Websocket using <code>IDOM_WEBSOCKET_PATH</code>.</p> asgi.py <pre><code>import os\nfrom django.core.asgi import get_asgi_application\n\n# Ensure DJANGO_SETTINGS_MODULE is set properly based on your project name!\nos.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"example_project.settings\")\ndjango_asgi_app = get_asgi_application()\n\nfrom channels.auth import AuthMiddlewareStack\nfrom channels.routing import ProtocolTypeRouter, URLRouter\nfrom channels.sessions import SessionMiddlewareStack\nfrom django_idom import IDOM_WEBSOCKET_PATH\n\napplication = ProtocolTypeRouter(\n    {\n        \"http\": django_asgi_app,\n        \"websocket\": SessionMiddlewareStack(\n            AuthMiddlewareStack(URLRouter([IDOM_WEBSOCKET_PATH]))\n        ),\n    }\n)\n</code></pre> Where is my <code>asgi.py</code>? <p>If you do not have an <code>asgi.py</code>, follow the <code>channels</code> installation guide.</p>"},{"location":"getting-started/learn-more/","title":"Congratulations","text":"<p>If you followed the previous steps, you have now created a \"Hello World\" component!</p> <p>The docs you are reading only covers our Django integration. To learn more about features, such as interactive events and hooks, check out the IDOM Core Documentation!</p> <p>Additionally, the vast majority of tutorials/guides you find for React can be applied to IDOM.</p> Learn More Django-IDOM Advanced Usage IDOM Core Documentation Ask Questions on GitHub Discussions"},{"location":"getting-started/reference-component/","title":"4. Use the Template Tag","text":"Summary <p>Decide where the component will be displayed by using our template tag.</p> <p>In your Django app's HTML template, you can now embed your IDOM component using the <code>component</code> template tag. Within this tag, you will need to type in your dotted path to the component function as the first argument.</p> <p>Additionally, you can pass in keyword arguments into your component function. For example, after reading the code below, pay attention to how the function definition for <code>hello_world</code> (in the previous example) accepts a <code>recipient</code> argument.</p> my-template.html <pre><code>{% load idom %}\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;body&gt;\n{% component \"example_project.my_app.components.hello_world\" recipient=\"World\" %}\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> Do not use context variables for the IDOM component name <p>Our pre-processor relies on the template tag containing a string.</p> <p>Do not use Django template/context variables for the component path. Failure to follow this warning will result in unexpected behavior.</p> <p>For example, do not do the following:</p> my-template.htmlviews.py <pre><code>&lt;!-- This is bad --&gt;\n{% component dont_do_this recipient=\"World\" %}\n\n&lt;!-- This is good --&gt;\n{% component \"example_project.my_app.components.hello_world\" recipient=\"World\" %}\n</code></pre> <pre><code>def example_view():\n    context_vars = {\"dont_do_this\": \"example_project.my_app.components.hello_world\"}\n    return render(request, \"my-template.html\", context_vars)\n</code></pre> Reserved keyword arguments: <code>class</code> and <code>key</code> <p>For this template tag, there are two reserved keyword arguments: <code>class</code> and <code>key</code></p> <ul> <li><code>class</code> allows you to apply a HTML class to the top-level component div. This is useful for styling purposes.</li> <li><code>key</code> allows you to force the component to use a specific key value. You typically won't need to set this.</li> </ul> my-template.html <pre><code>...\n{% component \"example.components.my_component\" class=\"my-html-class\" key=123 %}\n...\n</code></pre> Can I use multiple components on one page? <p>You can add as many components to a webpage as needed by using the template tag multiple times. Retrofitting legacy sites to use IDOM will typically involve many components on one page.</p> my-template.html <pre><code>{% load idom %}\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;body&gt;\n{% component \"example_project.my_app.components.hello_world\" recipient=\"World\" %}\n{% component \"example_project.my_app_2.components.class_component\" class=\"bold small-font\" %}\n    &lt;div&gt;{% component \"example_project.my_app_3.components.simple_component\" %}&lt;/div&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>But keep in mind, in scenarios where you are trying to create a Single Page Application (SPA) within Django, you will only have one central component within your <code>&lt;body&gt;</code> tag.</p> <p>Additionally, the components in the example above will not be able to interact with each other, except through database queries.</p> Can I use positional arguments instead of keyword arguments? <p>You can only pass in keyword arguments within the template tag. Due to technical limitations, positional arguments are not supported at this time.</p> What is a \"template tag\"? <p>You can think of template tags as Django's way of allowing you to run Python code within your HTML. Django-IDOM uses a <code>{% component ... %}</code> template tag to perform it's magic.</p> <p>Keep in mind, in order to use the <code>{% component ... %}</code> tag, you will need to first call <code>{% load idom %}</code> to gain access to it.</p> my-template.html <pre><code>{% load idom %}\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;body&gt;\n{% component \"example_project.my_app.components.hello_world\" recipient=\"World\" %}\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> Where is my templates folder? <p>If you do not have a <code>templates</code> folder in your Django app, you can simply create one! Keep in mind, templates within this folder will not be detected by Django unless you add the corresponding Django app to <code>settings.py:INSTALLED_APPS</code>.</p>"},{"location":"getting-started/render-view/","title":"5. Render Your View","text":"Summary <p>Select your template containing an IDOM component, and render it using a Django view.</p> <p>We will assume you have created a Django View before, but here's a simple example below.</p> <p>Within your Django app's <code>views.py</code> file, you will need to create a function to render the HTML template containing your IDOM components.</p> <p>In this example, we will create a view that renders <code>my-template.html</code> (from the previous step).</p> views.py <pre><code>from django.shortcuts import render\n\ndef index(request):\n    return render(request, \"my-template.html\")\n</code></pre> <p>We will add this new view into your <code>urls.py</code>.</p> urls.py <pre><code>from django.urls import path\nfrom example_project.my_app import views\n\nurlpatterns = [\n    path(\"example/\", views.index),\n]\n</code></pre> <p>Now, navigate to <code>http://127.0.0.1:8000/example/</code>. If you copy-pasted the component from the previous example, you will now see your component display \"Hello World\".</p> Which urls.py do I add my views to? <p>For simple Django projects, you can easily add all of your views directly into the Django project's <code>urls.py</code>. However, as you start increase your project's complexity you might end up with way too much within one file.</p> <p>Once you reach that point, we recommend creating an individual <code>urls.py</code> within each of your Django apps.</p> <p>Then, within your Django project's <code>urls.py</code> you will use Django's <code>include</code> function to link it all together.</p>"}]}