{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Django IDOM \u00b7 \u00b6 ReactJS for Django Developers. \u00b6 Django-IDOM connects your Python project to a ReactJS front-end, allowing you to create interactive websites without needing JavaScript! Following ReactJS styling, web elements are combined into reusable \"components\" . These components can utilize hooks and events to create infinitely complex web pages. When needed, IDOM can use components directly from NPM . For additional flexibility, components can also be fully developed in JavaScript . Any Python web framework with Websockets can support IDOM. See below for what frameworks are supported out of the box. Supported Frameworks Supported Frameworks (External) Flask , FastAPI , Sanic , Tornado Django , Plotly-Dash , Jupyter Resources \u00b6 Follow the links below to find out more about this project. Try it Now - Check out IDOM in a Jupyter Notebook. Documentation - Learn how to install, run, and use IDOM. Community Forum - Ask questions, share ideas, and show off projects.","title":"Home"},{"location":"#django-idom","text":"","title":"Django IDOM &middot;"},{"location":"#reactjs-for-django-developers","text":"Django-IDOM connects your Python project to a ReactJS front-end, allowing you to create interactive websites without needing JavaScript! Following ReactJS styling, web elements are combined into reusable \"components\" . These components can utilize hooks and events to create infinitely complex web pages. When needed, IDOM can use components directly from NPM . For additional flexibility, components can also be fully developed in JavaScript . Any Python web framework with Websockets can support IDOM. See below for what frameworks are supported out of the box. Supported Frameworks Supported Frameworks (External) Flask , FastAPI , Sanic , Tornado Django , Plotly-Dash , Jupyter","title":"ReactJS for Django Developers."},{"location":"#resources","text":"Follow the links below to find out more about this project. Try it Now - Check out IDOM in a Jupyter Notebook. Documentation - Learn how to install, run, and use IDOM. Community Forum - Ask questions, share ideas, and show off projects.","title":"Resources"},{"location":"changelog/","text":"Attribution The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . Unreleased \u00b6 Nothing (yet) 2.1.0 - 2022-11-01 \u00b6 Changed \u00b6 Minimum channels version is now 4.0.0 . Fixed \u00b6 Change type hint on view_to_component callable to have request argument be optional. Change type hint on view_to_component to represent it as a decorator with parenthesis (such as @view_to_component(compatibility=True) ) Security \u00b6 Add note to docs about potential information exposure via view_to_component when using compatibility=True . 2.0.1 - 2022-10-18 \u00b6 Fixed \u00b6 Ability to use key=... parameter on all prefabricated components. 2.0.0 - 2022-10-17 \u00b6 Added \u00b6 use_origin hook for returning the browser's location.origin . Changed \u00b6 view_to_component now returns a Callable , instead of directly returning a Component . Check the docs for new usage info. use_mutation and use_query will now log any query failures. Fixed \u00b6 Allow use_mutation to have refetch=None , as the docs suggest is possible. use_query will now prefetch all fields to prevent SynchronousOnlyOperation exceptions. view_to_component , django_css , and django_js type hints will now display like normal functions. IDOM preloader no longer attempts to parse commented out IDOM components. Tests are now fully functional on Windows 1.2.0 - 2022-09-19 \u00b6 Added \u00b6 auth_required decorator to prevent your components from rendering to unauthenticated users. use_query hook for fetching database values. use_mutation hook for modifying database values. view_to_component utility to convert legacy Django views to IDOM components. Changed \u00b6 Bumped the minimum IDOM version to 0.40.2 Testing suite now uses playwright instead of selenium Fixed \u00b6 IDOM preloader is no longer sensitive to whitespace within template tags. 1.1.0 - 2022-07-01 \u00b6 Added \u00b6 django_css and django_js components to defer loading CSS & JS files until needed. Changed \u00b6 Bumped the minimum IDOM version to 0.39.0 1.0.0 - 2022-05-22 \u00b6 Added \u00b6 Django-specific hooks! use_websocket , use_scope , and use_location are now available within the django_idom.hooks module. Documentation has been placed into a formal docs webpage. Logging for when a component fails to import, or if no components were found within Django. Changed \u00b6 idom_component template tag has been renamed to component Bumped the minimum IDOM version to 0.38.0 Removed \u00b6 websocket parameter for components has been removed. Functionally, it is replaced with django_idom.hooks.use_websocket . 0.0.5 - 2022-04-04 \u00b6 Changed \u00b6 Bumped the minimum IDOM version to 0.37.2 Fixed \u00b6 ModuleNotFoundError: No module named idom.core.proto caused by IDOM 0.37.2 0.0.4 - 2022-03-05 \u00b6 Changed \u00b6 Bumped the minimum IDOM version to 0.37.1 0.0.3 - 2022-02-19 \u00b6 Changed \u00b6 Bumped the minimum IDOM version to 0.36.3 0.0.2 - 2022-01-30 \u00b6 Added \u00b6 Ability to declare the HTML class of the top-level component div name = ... parameter to IDOM HTTP paths for use with django.urls.reverse() Cache versioning to automatically invalidate old web module files from the cache back-end Automatic pre-population of the IDOM component registry Type hinting for IdomWebsocket Changed \u00b6 Fetching web modules from disk and/or cache is now fully async Static files are now contained within a django_idom/ parent folder Upgraded IDOM to version 0.36.0 Minimum Django version required is now 4.0 Minimum Python version required is now 3.8 Removed \u00b6 IDOM_WEB_MODULES_PATH has been replaced with Django include(...) IDOM_WS_MAX_RECONNECT_DELAY has been renamed to IDOM_WS_MAX_RECONNECT_TIMEOUT idom_web_modules cache back-end has been renamed to idom Fixed \u00b6 Increase test timeout values to prevent false positives Windows compatibility for building Django-IDOM Security \u00b6 Fixed potential directory traversal attack on the IDOM web modules URL 0.0.1 - 2021-08-18 \u00b6 Added \u00b6 Support for IDOM within the Django","title":"Changelog"},{"location":"changelog/#unreleased","text":"Nothing (yet)","title":"Unreleased"},{"location":"changelog/#210-2022-11-01","text":"","title":"2.1.0 - 2022-11-01"},{"location":"changelog/#changed","text":"Minimum channels version is now 4.0.0 .","title":"Changed"},{"location":"changelog/#fixed","text":"Change type hint on view_to_component callable to have request argument be optional. Change type hint on view_to_component to represent it as a decorator with parenthesis (such as @view_to_component(compatibility=True) )","title":"Fixed"},{"location":"changelog/#security","text":"Add note to docs about potential information exposure via view_to_component when using compatibility=True .","title":"Security"},{"location":"changelog/#201-2022-10-18","text":"","title":"2.0.1 - 2022-10-18"},{"location":"changelog/#fixed_1","text":"Ability to use key=... parameter on all prefabricated components.","title":"Fixed"},{"location":"changelog/#200-2022-10-17","text":"","title":"2.0.0 - 2022-10-17"},{"location":"changelog/#added","text":"use_origin hook for returning the browser's location.origin .","title":"Added"},{"location":"changelog/#changed_1","text":"view_to_component now returns a Callable , instead of directly returning a Component . Check the docs for new usage info. use_mutation and use_query will now log any query failures.","title":"Changed"},{"location":"changelog/#fixed_2","text":"Allow use_mutation to have refetch=None , as the docs suggest is possible. use_query will now prefetch all fields to prevent SynchronousOnlyOperation exceptions. view_to_component , django_css , and django_js type hints will now display like normal functions. IDOM preloader no longer attempts to parse commented out IDOM components. Tests are now fully functional on Windows","title":"Fixed"},{"location":"changelog/#120-2022-09-19","text":"","title":"1.2.0 - 2022-09-19"},{"location":"changelog/#added_1","text":"auth_required decorator to prevent your components from rendering to unauthenticated users. use_query hook for fetching database values. use_mutation hook for modifying database values. view_to_component utility to convert legacy Django views to IDOM components.","title":"Added"},{"location":"changelog/#changed_2","text":"Bumped the minimum IDOM version to 0.40.2 Testing suite now uses playwright instead of selenium","title":"Changed"},{"location":"changelog/#fixed_3","text":"IDOM preloader is no longer sensitive to whitespace within template tags.","title":"Fixed"},{"location":"changelog/#110-2022-07-01","text":"","title":"1.1.0 - 2022-07-01"},{"location":"changelog/#added_2","text":"django_css and django_js components to defer loading CSS & JS files until needed.","title":"Added"},{"location":"changelog/#changed_3","text":"Bumped the minimum IDOM version to 0.39.0","title":"Changed"},{"location":"changelog/#100-2022-05-22","text":"","title":"1.0.0 - 2022-05-22"},{"location":"changelog/#added_3","text":"Django-specific hooks! use_websocket , use_scope , and use_location are now available within the django_idom.hooks module. Documentation has been placed into a formal docs webpage. Logging for when a component fails to import, or if no components were found within Django.","title":"Added"},{"location":"changelog/#changed_4","text":"idom_component template tag has been renamed to component Bumped the minimum IDOM version to 0.38.0","title":"Changed"},{"location":"changelog/#removed","text":"websocket parameter for components has been removed. Functionally, it is replaced with django_idom.hooks.use_websocket .","title":"Removed"},{"location":"changelog/#005-2022-04-04","text":"","title":"0.0.5 - 2022-04-04"},{"location":"changelog/#changed_5","text":"Bumped the minimum IDOM version to 0.37.2","title":"Changed"},{"location":"changelog/#fixed_4","text":"ModuleNotFoundError: No module named idom.core.proto caused by IDOM 0.37.2","title":"Fixed"},{"location":"changelog/#004-2022-03-05","text":"","title":"0.0.4 - 2022-03-05"},{"location":"changelog/#changed_6","text":"Bumped the minimum IDOM version to 0.37.1","title":"Changed"},{"location":"changelog/#003-2022-02-19","text":"","title":"0.0.3 - 2022-02-19"},{"location":"changelog/#changed_7","text":"Bumped the minimum IDOM version to 0.36.3","title":"Changed"},{"location":"changelog/#002-2022-01-30","text":"","title":"0.0.2 - 2022-01-30"},{"location":"changelog/#added_4","text":"Ability to declare the HTML class of the top-level component div name = ... parameter to IDOM HTTP paths for use with django.urls.reverse() Cache versioning to automatically invalidate old web module files from the cache back-end Automatic pre-population of the IDOM component registry Type hinting for IdomWebsocket","title":"Added"},{"location":"changelog/#changed_8","text":"Fetching web modules from disk and/or cache is now fully async Static files are now contained within a django_idom/ parent folder Upgraded IDOM to version 0.36.0 Minimum Django version required is now 4.0 Minimum Python version required is now 3.8","title":"Changed"},{"location":"changelog/#removed_1","text":"IDOM_WEB_MODULES_PATH has been replaced with Django include(...) IDOM_WS_MAX_RECONNECT_DELAY has been renamed to IDOM_WS_MAX_RECONNECT_TIMEOUT idom_web_modules cache back-end has been renamed to idom","title":"Removed"},{"location":"changelog/#fixed_5","text":"Increase test timeout values to prevent false positives Windows compatibility for building Django-IDOM","title":"Fixed"},{"location":"changelog/#security_1","text":"Fixed potential directory traversal attack on the IDOM web modules URL","title":"Security"},{"location":"changelog/#001-2021-08-18","text":"","title":"0.0.1 - 2021-08-18"},{"location":"changelog/#added_5","text":"Support for IDOM within the Django","title":"Added"},{"location":"contribute/code/","text":"Looking to contribute features that are not Django specific? Everything within the django-idom repository must be specific to Django integration. Check out the IDOM Core documentation to contribute general features such as: components, hooks, events, and more. If you plan to make code changes to this repository, you will need to install the following dependencies first: Python 3.8+ Git NPM for installing and managing Javascript Once done, you should clone this repository: git clone https://github.com/idom-team/django-idom.git cd django-idom Then, by running the command below you can: Install an editable version of the Python code Download, build, and install Javascript dependencies pip install -e . -r requirements.txt Finally, to verify that everything is working properly, you can manually run the development webserver. cd tests python manage.py runserver Navigate to http://127.0.0.1:8000 to see if the tests are rendering correctly.","title":"Code"},{"location":"contribute/docs/","text":"If you plan to make changes to this documentation, you will need to install the following dependencies first: Python 3.8+ Git Once done, you should clone this repository: git clone https://github.com/idom-team/django-idom.git cd django-idom Then, by running the command below you can: Install an editable version of the documentation Self-host a test server for the documentation pip install -r ./requirements/build-docs.txt --upgrade Finally, to verify that everything is working properly, you can manually run the docs preview webserver. mkdocs serve Navigate to http://127.0.0.1:8000 to view a preview of the documentation.","title":"Docs"},{"location":"contribute/running-tests/","text":"This repository uses Nox to run tests. For a full test of available scripts run nox -l . If you plan to run tests, you will need to install the following dependencies first: Python 3.8+ Git Once done, you should clone this repository: git clone https://github.com/idom-team/django-idom.git cd django-idom pip install -r ./requirements/test-run.txt --upgrade Then, by running the command below you can run the full test suite: nox -s test Or, if you want to run the tests in the foreground: nox -s test -- --headed","title":"Running Tests"},{"location":"features/components/","text":"Summary Prefabricated components can be used within your components.py to help simplify development. View To Component \u00b6 Convert any Django view into a IDOM component by using this decorator. Compatible with Function Based Views and Class Based Views . Views can be sync or async. components.py 1 2 3 4 5 6 7 8 9 10 11 12 13 from idom import component , html from django.http import HttpResponse from django_idom.components import view_to_component @view_to_component def hello_world_view ( request ): return HttpResponse ( \"Hello World!\" ) @component def my_component (): return html . div ( hello_world_view (), ) See Interface Parameters Name Type Description Default view Callable | View The view function or class to convert. N/A compatibility bool If True, the component will be rendered in an iframe. When using compatibility mode tranforms , strict_parsing , request , args , and kwargs arguments will be ignored. False transforms Sequence[Callable[[VdomDict], Any]] A list of functions that transforms the newly generated VDOM. The functions will be called on each VDOM node. tuple strict_parsing bool If True, an exception will be generated if the HTML does not perfectly adhere to HTML5. True Returns Type Description _ViewComponentConstructor A function that takes request: HttpRequest | None, *args: Any, key: Key | None, **kwargs: Any and returns an IDOM component. Potential information exposure when using compatibility = True When using compatibility mode, IDOM automatically exposes a URL to your view. It is your responsibility to ensure privileged information is not leaked via this method. This can be done via directly writing conditionals into your view, or by adding decorators such as user_passes_test to your views prior to using view_to_component . Function Based View Class Based View ... @view_to_component ( compatibility = True ) @user_passes_test ( lambda u : u . is_superuser ) def example_view ( request ): ... ... @view_to_component ( compatibility = True ) @method_decorator ( user_passes_test ( lambda u : u . is_superuser ), name = \"dispatch\" ) class ExampleView ( TemplateView ): ... Existing limitations There are currently several limitations of using view_to_component that may be resolved in a future version of django_idom . Requires manual intervention to change request methods beyond GET . IDOM events cannot conveniently be attached to converted view HTML. Does not currently load any HTML contained with a <head> tag Has no option to automatically intercept local anchor link (such as < a href = 'example/' ></ a > ) click events Please note these limitations do not exist when using compatibility mode. How do I use this for Class Based Views? You can simply pass your Class Based View directly into view_to_component . components.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from idom import component , html from django.http import HttpResponse from django.views import View from django_idom.components import view_to_component @view_to_component class HelloWorldView ( View ): def get ( self , request ): return HttpResponse ( \"Hello World!\" ) @component def my_component (): return html . div ( HelloWorldView (), ) How do I transform views from external libraries? In order to convert external views, you can utilize view_to_component as a function, rather than a decorator. components.py 1 2 3 4 5 6 7 8 9 10 11 12 from idom import component , html from django.http import HttpResponse from django_idom.components import view_to_component from some_library.views import example_view example_vtc = view_to_component ( example_view ) @component def my_component (): return html . div ( example_vtc (), ) How do I provide request , args , and kwargs to a view? Request You can use the request parameter to provide the view a custom request object. components.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from idom import component , html from django.http import HttpResponse , HttpRequest from django_idom.components import view_to_component example_request = HttpRequest () example_request . method = \"PUT\" @view_to_component def hello_world_view ( request ): return HttpResponse ( f \"Hello World! { request . method } \" ) @component def my_component (): return html . div ( hello_world_view ( example_request , ), ) args and kwargs You can use the args and kwargs parameters to provide positional and keyworded arguments to a view. components.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from idom import component , html from django.http import HttpResponse from django_idom.components import view_to_component @view_to_component def hello_world_view ( request , arg1 , arg2 , key1 = None , key2 = None ): return HttpResponse ( f \"Hello World! { arg1 } { arg2 } { key1 } { key2 } \" ) @component def my_component (): return html . div ( hello_world_view ( None , # Your request object (optional) \"value_1\" , \"value_2\" , key1 = \"abc\" , key2 = \"123\" , ), ) How do I use strict_parseing , compatibility , and transforms ? strict_parsing By default, an exception will be generated if your view's HTML does not perfectly adhere to HTML5. However, there are some circumstances where you may not have control over the original HTML, so you may be unable to fix it. Or you may be relying on non-standard HTML tags such as < my-tag > Hello World </ my-tag > . In these scenarios, you may want to rely on best-fit parsing by setting the strict_parsing parameter to False . Note that best-fit parsing is designed to be similar to how web browsers would handle non-standard or broken HTML. components.py 1 2 3 4 5 6 7 8 9 10 11 12 13 from idom import component , html from django.http import HttpResponse from django_idom.components import view_to_component @view_to_component ( strict_parsing = False ) def hello_world_view ( request ): return HttpResponse ( \"<my-tag> Hello World </my-tag>\" ) @component def my_component (): return html . div ( hello_world_view (), ) compatibility For views that rely on HTTP responses other than GET (such as PUT , POST , PATCH , etc), you should consider using compatibility mode to render your view within an iframe. Any view can be rendered within compatibility mode. However, the transforms , strict_parsing , request , args , and kwargs arguments do not apply to compatibility mode. Please note that by default the iframe is unstyled, and thus won't look pretty until you add some CSS. components.py 1 2 3 4 5 6 7 8 9 10 11 12 13 from idom import component , html from django.http import HttpResponse from django_idom.components import view_to_component @view_to_component ( compatibility = True ) def hello_world_view ( request ): return HttpResponse ( \"Hello World!\" ) @component def my_component (): return html . div ( hello_world_view (), ) transforms After your view has been turned into VDOM (python dictionaries), view_to_component will call your transforms functions on every VDOM node. This allows you to modify your view prior to rendering. For example, if you are trying to modify the text of a node with a certain id , you can create a transform like such: components.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from idom import component , html from django.http import HttpResponse from django_idom.components import view_to_component def example_transform ( vdom ): attributes = vdom . get ( \"attributes\" ) if attributes and attributes . get ( \"id\" ) == \"hello-world\" : vdom [ \"children\" ][ 0 ] = \"Good Bye World!\" @view_to_component ( transforms = [ example_transform ]) def hello_world_view ( request ): return HttpResponse ( \"<div id='hello-world'> Hello World! <div>\" ) @component def my_component (): return html . div ( hello_world_view (), ) Django CSS \u00b6 Allows you to defer loading a CSS stylesheet until a component begins rendering. This stylesheet must be stored within Django's static files . components.py 1 2 3 4 5 6 7 8 9 from idom import component , html from django_idom.components import django_css @component def my_component (): return html . div ( django_css ( \"css/buttons.css\" ), html . button ( \"My Button!\" ), ) See Interface Parameters Name Type Description Default static_path str The path to the static file. This path is identical to what you would use on a static template tag. N/A key Key | None A key to uniquely identify this component which is unique amongst a component's immediate siblings None Returns Type Description Component An IDOM component. Should I put django_css at the top of my component? Yes, if the stylesheet contains styling for your component. Can I load static CSS using html.link instead? While you can load stylesheets with html.link , keep in mind that loading this way does not ensure load order. Thus, your stylesheet will be loaded after your component is displayed. This would likely cause unintended visual behavior, so use this at your own discretion. Here's an example on what you should avoid doing for Django static files: 1 2 3 4 5 6 7 8 9 from idom import component , html from django.templatetags.static import static @component def my_component (): return html . div ( html . link ({ \"rel\" : \"stylesheet\" , \"href\" : static ( \"css/buttons.css\" )}), html . button ( \"My Button!\" ), ) How do I load external CSS? django_css can only be used with local static files. For external CSS, substitute django_css with html.link . 1 2 3 4 5 6 7 8 from idom import component , html @component def my_component (): return html . div ( html . link ({ \"rel\" : \"stylesheet\" , \"href\" : \"https://example.com/external-styles.css\" }), html . button ( \"My Button!\" ), ) Why not load my CSS in < head > ? Traditionally, stylesheets are loaded in your < head > using the {% load static %} template tag. To help improve webpage load times, you can use the django_css component to defer loading your stylesheet until it is needed. Django JS \u00b6 Allows you to defer loading JavaScript until a component begins rendering. This JavaScript must be stored within Django's static files . components.py 1 2 3 4 5 6 7 8 9 from idom import component , html from django_idom.components import django_js @component def my_component (): return html . div ( html . button ( \"My Button!\" ), django_js ( \"js/scripts.js\" ), ) See Interface Parameters Name Type Description Default static_path str The path to the static file. This path is identical to what you would use on a static template tag. N/A key Key | None A key to uniquely identify this component which is unique amongst a component's immediate siblings None Returns Type Description Component An IDOM component. Should I put django_js at the bottom of my component? Yes, if your scripts are reliant on the contents of the component. Can I load static JavaScript using html.script instead? While you can load JavaScript with html.script , keep in mind that loading this way does not ensure load order. Thus, your JavaScript will likely be loaded at an arbitrary time after your component is displayed. Here's an example on what you should avoid doing for Django static files: 1 2 3 4 5 6 7 8 9 from idom import component , html from django.templatetags.static import static @component def my_component (): return html . div ( html . script ({ \"src\" : static ( \"js/scripts.js\" )}), html . button ( \"My Button!\" ), ) How do I load external JS? django_js can only be used with local static files. For external JavaScript, substitute django_js with html.script . 1 2 3 4 5 6 7 8 from idom import component , html @component def my_component (): return html . div ( html . script ({ \"src\" : \"https://example.com/external-scripts.js\" }), html . button ( \"My Button!\" ), ) Why not load my JS in < head > ? Traditionally, JavaScript is loaded in your < head > using the {% load static %} template tag. To help improve webpage load times, you can use the django_js component to defer loading your JavaScript until it is needed.","title":"Components"},{"location":"features/components/#view-to-component","text":"Convert any Django view into a IDOM component by using this decorator. Compatible with Function Based Views and Class Based Views . Views can be sync or async. components.py 1 2 3 4 5 6 7 8 9 10 11 12 13 from idom import component , html from django.http import HttpResponse from django_idom.components import view_to_component @view_to_component def hello_world_view ( request ): return HttpResponse ( \"Hello World!\" ) @component def my_component (): return html . div ( hello_world_view (), ) See Interface Parameters Name Type Description Default view Callable | View The view function or class to convert. N/A compatibility bool If True, the component will be rendered in an iframe. When using compatibility mode tranforms , strict_parsing , request , args , and kwargs arguments will be ignored. False transforms Sequence[Callable[[VdomDict], Any]] A list of functions that transforms the newly generated VDOM. The functions will be called on each VDOM node. tuple strict_parsing bool If True, an exception will be generated if the HTML does not perfectly adhere to HTML5. True Returns Type Description _ViewComponentConstructor A function that takes request: HttpRequest | None, *args: Any, key: Key | None, **kwargs: Any and returns an IDOM component. Potential information exposure when using compatibility = True When using compatibility mode, IDOM automatically exposes a URL to your view. It is your responsibility to ensure privileged information is not leaked via this method. This can be done via directly writing conditionals into your view, or by adding decorators such as user_passes_test to your views prior to using view_to_component . Function Based View Class Based View ... @view_to_component ( compatibility = True ) @user_passes_test ( lambda u : u . is_superuser ) def example_view ( request ): ... ... @view_to_component ( compatibility = True ) @method_decorator ( user_passes_test ( lambda u : u . is_superuser ), name = \"dispatch\" ) class ExampleView ( TemplateView ): ... Existing limitations There are currently several limitations of using view_to_component that may be resolved in a future version of django_idom . Requires manual intervention to change request methods beyond GET . IDOM events cannot conveniently be attached to converted view HTML. Does not currently load any HTML contained with a <head> tag Has no option to automatically intercept local anchor link (such as < a href = 'example/' ></ a > ) click events Please note these limitations do not exist when using compatibility mode. How do I use this for Class Based Views? You can simply pass your Class Based View directly into view_to_component . components.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from idom import component , html from django.http import HttpResponse from django.views import View from django_idom.components import view_to_component @view_to_component class HelloWorldView ( View ): def get ( self , request ): return HttpResponse ( \"Hello World!\" ) @component def my_component (): return html . div ( HelloWorldView (), ) How do I transform views from external libraries? In order to convert external views, you can utilize view_to_component as a function, rather than a decorator. components.py 1 2 3 4 5 6 7 8 9 10 11 12 from idom import component , html from django.http import HttpResponse from django_idom.components import view_to_component from some_library.views import example_view example_vtc = view_to_component ( example_view ) @component def my_component (): return html . div ( example_vtc (), ) How do I provide request , args , and kwargs to a view? Request You can use the request parameter to provide the view a custom request object. components.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from idom import component , html from django.http import HttpResponse , HttpRequest from django_idom.components import view_to_component example_request = HttpRequest () example_request . method = \"PUT\" @view_to_component def hello_world_view ( request ): return HttpResponse ( f \"Hello World! { request . method } \" ) @component def my_component (): return html . div ( hello_world_view ( example_request , ), ) args and kwargs You can use the args and kwargs parameters to provide positional and keyworded arguments to a view. components.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from idom import component , html from django.http import HttpResponse from django_idom.components import view_to_component @view_to_component def hello_world_view ( request , arg1 , arg2 , key1 = None , key2 = None ): return HttpResponse ( f \"Hello World! { arg1 } { arg2 } { key1 } { key2 } \" ) @component def my_component (): return html . div ( hello_world_view ( None , # Your request object (optional) \"value_1\" , \"value_2\" , key1 = \"abc\" , key2 = \"123\" , ), ) How do I use strict_parseing , compatibility , and transforms ? strict_parsing By default, an exception will be generated if your view's HTML does not perfectly adhere to HTML5. However, there are some circumstances where you may not have control over the original HTML, so you may be unable to fix it. Or you may be relying on non-standard HTML tags such as < my-tag > Hello World </ my-tag > . In these scenarios, you may want to rely on best-fit parsing by setting the strict_parsing parameter to False . Note that best-fit parsing is designed to be similar to how web browsers would handle non-standard or broken HTML. components.py 1 2 3 4 5 6 7 8 9 10 11 12 13 from idom import component , html from django.http import HttpResponse from django_idom.components import view_to_component @view_to_component ( strict_parsing = False ) def hello_world_view ( request ): return HttpResponse ( \"<my-tag> Hello World </my-tag>\" ) @component def my_component (): return html . div ( hello_world_view (), ) compatibility For views that rely on HTTP responses other than GET (such as PUT , POST , PATCH , etc), you should consider using compatibility mode to render your view within an iframe. Any view can be rendered within compatibility mode. However, the transforms , strict_parsing , request , args , and kwargs arguments do not apply to compatibility mode. Please note that by default the iframe is unstyled, and thus won't look pretty until you add some CSS. components.py 1 2 3 4 5 6 7 8 9 10 11 12 13 from idom import component , html from django.http import HttpResponse from django_idom.components import view_to_component @view_to_component ( compatibility = True ) def hello_world_view ( request ): return HttpResponse ( \"Hello World!\" ) @component def my_component (): return html . div ( hello_world_view (), ) transforms After your view has been turned into VDOM (python dictionaries), view_to_component will call your transforms functions on every VDOM node. This allows you to modify your view prior to rendering. For example, if you are trying to modify the text of a node with a certain id , you can create a transform like such: components.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from idom import component , html from django.http import HttpResponse from django_idom.components import view_to_component def example_transform ( vdom ): attributes = vdom . get ( \"attributes\" ) if attributes and attributes . get ( \"id\" ) == \"hello-world\" : vdom [ \"children\" ][ 0 ] = \"Good Bye World!\" @view_to_component ( transforms = [ example_transform ]) def hello_world_view ( request ): return HttpResponse ( \"<div id='hello-world'> Hello World! <div>\" ) @component def my_component (): return html . div ( hello_world_view (), )","title":"View To Component"},{"location":"features/components/#django-css","text":"Allows you to defer loading a CSS stylesheet until a component begins rendering. This stylesheet must be stored within Django's static files . components.py 1 2 3 4 5 6 7 8 9 from idom import component , html from django_idom.components import django_css @component def my_component (): return html . div ( django_css ( \"css/buttons.css\" ), html . button ( \"My Button!\" ), ) See Interface Parameters Name Type Description Default static_path str The path to the static file. This path is identical to what you would use on a static template tag. N/A key Key | None A key to uniquely identify this component which is unique amongst a component's immediate siblings None Returns Type Description Component An IDOM component. Should I put django_css at the top of my component? Yes, if the stylesheet contains styling for your component. Can I load static CSS using html.link instead? While you can load stylesheets with html.link , keep in mind that loading this way does not ensure load order. Thus, your stylesheet will be loaded after your component is displayed. This would likely cause unintended visual behavior, so use this at your own discretion. Here's an example on what you should avoid doing for Django static files: 1 2 3 4 5 6 7 8 9 from idom import component , html from django.templatetags.static import static @component def my_component (): return html . div ( html . link ({ \"rel\" : \"stylesheet\" , \"href\" : static ( \"css/buttons.css\" )}), html . button ( \"My Button!\" ), ) How do I load external CSS? django_css can only be used with local static files. For external CSS, substitute django_css with html.link . 1 2 3 4 5 6 7 8 from idom import component , html @component def my_component (): return html . div ( html . link ({ \"rel\" : \"stylesheet\" , \"href\" : \"https://example.com/external-styles.css\" }), html . button ( \"My Button!\" ), ) Why not load my CSS in < head > ? Traditionally, stylesheets are loaded in your < head > using the {% load static %} template tag. To help improve webpage load times, you can use the django_css component to defer loading your stylesheet until it is needed.","title":"Django CSS"},{"location":"features/components/#django-js","text":"Allows you to defer loading JavaScript until a component begins rendering. This JavaScript must be stored within Django's static files . components.py 1 2 3 4 5 6 7 8 9 from idom import component , html from django_idom.components import django_js @component def my_component (): return html . div ( html . button ( \"My Button!\" ), django_js ( \"js/scripts.js\" ), ) See Interface Parameters Name Type Description Default static_path str The path to the static file. This path is identical to what you would use on a static template tag. N/A key Key | None A key to uniquely identify this component which is unique amongst a component's immediate siblings None Returns Type Description Component An IDOM component. Should I put django_js at the bottom of my component? Yes, if your scripts are reliant on the contents of the component. Can I load static JavaScript using html.script instead? While you can load JavaScript with html.script , keep in mind that loading this way does not ensure load order. Thus, your JavaScript will likely be loaded at an arbitrary time after your component is displayed. Here's an example on what you should avoid doing for Django static files: 1 2 3 4 5 6 7 8 9 from idom import component , html from django.templatetags.static import static @component def my_component (): return html . div ( html . script ({ \"src\" : static ( \"js/scripts.js\" )}), html . button ( \"My Button!\" ), ) How do I load external JS? django_js can only be used with local static files. For external JavaScript, substitute django_js with html.script . 1 2 3 4 5 6 7 8 from idom import component , html @component def my_component (): return html . div ( html . script ({ \"src\" : \"https://example.com/external-scripts.js\" }), html . button ( \"My Button!\" ), ) Why not load my JS in < head > ? Traditionally, JavaScript is loaded in your < head > using the {% load static %} template tag. To help improve webpage load times, you can use the django_js component to defer loading your JavaScript until it is needed.","title":"Django JS"},{"location":"features/decorators/","text":"Summary Decorator utilities can be used within your components.py to help simplify development. Auth Required \u00b6 You can limit access to a component to users with a specific auth_attribute by using this decorator. By default, this decorator checks if the user is logged in, and his/her account has not been deactivated. This decorator is commonly used to selectively render a component only if a user is_staff or is_superuser . This decorator can be used with or without parentheses. components.py 1 2 3 4 5 6 7 8 from django_idom.decorators import auth_required from django_idom.hooks import use_websocket from idom import component , html @component @auth_required def my_component (): return html . div ( \"I am logged in!\" ) See Interface Parameters Name Type Description Default auth_attribute str The value to check within the user object. This is checked in the form of UserModel.<auth_attribute> . \"is_active\" fallback ComponentType , VdomDict , None The component or idom.html snippet to render if the user is not authenticated. None Returns Type Description Component An IDOM component. VdomDict An idom.html snippet. None No component render. How do I render a different component if authentication fails? You can use a component with the fallback argument, as seen below. components.py 1 2 3 4 5 6 7 8 9 10 11 from django_idom.decorators import auth_required from idom import component , html @component def my_component_fallback (): return html . div ( \"I am NOT logged in!\" ) @component @auth_required ( fallback = my_component_fallback ) def my_component (): return html . div ( \"I am logged in!\" ) How do I render a simple idom.html snippet if authentication fails? You can use a idom.html snippet with the fallback argument, as seen below. components.py 1 2 3 4 5 6 7 8 from django_idom.decorators import auth_required from django_idom.hooks import use_websocket from idom import component , html @component @auth_required ( fallback = html . div ( \"I am NOT logged in!\" )) def my_component (): return html . div ( \"I am logged in!\" ) How can I check if a user is_staff ? You can set the auth_attribute to is_staff , as seen blow. components.py 1 2 3 4 5 6 7 8 9 from django_idom.decorators import auth_required from django_idom.hooks import use_websocket from idom import component , html @component @auth_required ( auth_attribute = \"is_staff\" ) def my_component (): return html . div ( \"I am logged in!\" ) How can I check for a custom attribute? You will need to be using a custom user model within your Django instance. For example, if your user model has the field is_really_cool ... models.py 1 2 3 4 5 6 from django.contrib.auth.models import AbstractBaseUser class CustomUserModel ( AbstractBaseUser ): @property def is_really_cool ( self ): return True ... then you would do the following within your decorator: components.py 1 2 3 4 5 6 7 8 from django_idom.decorators import auth_required from django_idom.hooks import use_websocket from idom import component , html @component @auth_required ( auth_attribute = \"is_really_cool\" ) def my_component (): return html . div ( \"I am logged in!\" )","title":"Decorators"},{"location":"features/decorators/#auth-required","text":"You can limit access to a component to users with a specific auth_attribute by using this decorator. By default, this decorator checks if the user is logged in, and his/her account has not been deactivated. This decorator is commonly used to selectively render a component only if a user is_staff or is_superuser . This decorator can be used with or without parentheses. components.py 1 2 3 4 5 6 7 8 from django_idom.decorators import auth_required from django_idom.hooks import use_websocket from idom import component , html @component @auth_required def my_component (): return html . div ( \"I am logged in!\" ) See Interface Parameters Name Type Description Default auth_attribute str The value to check within the user object. This is checked in the form of UserModel.<auth_attribute> . \"is_active\" fallback ComponentType , VdomDict , None The component or idom.html snippet to render if the user is not authenticated. None Returns Type Description Component An IDOM component. VdomDict An idom.html snippet. None No component render. How do I render a different component if authentication fails? You can use a component with the fallback argument, as seen below. components.py 1 2 3 4 5 6 7 8 9 10 11 from django_idom.decorators import auth_required from idom import component , html @component def my_component_fallback (): return html . div ( \"I am NOT logged in!\" ) @component @auth_required ( fallback = my_component_fallback ) def my_component (): return html . div ( \"I am logged in!\" ) How do I render a simple idom.html snippet if authentication fails? You can use a idom.html snippet with the fallback argument, as seen below. components.py 1 2 3 4 5 6 7 8 from django_idom.decorators import auth_required from django_idom.hooks import use_websocket from idom import component , html @component @auth_required ( fallback = html . div ( \"I am NOT logged in!\" )) def my_component (): return html . div ( \"I am logged in!\" ) How can I check if a user is_staff ? You can set the auth_attribute to is_staff , as seen blow. components.py 1 2 3 4 5 6 7 8 9 from django_idom.decorators import auth_required from django_idom.hooks import use_websocket from idom import component , html @component @auth_required ( auth_attribute = \"is_staff\" ) def my_component (): return html . div ( \"I am logged in!\" ) How can I check for a custom attribute? You will need to be using a custom user model within your Django instance. For example, if your user model has the field is_really_cool ... models.py 1 2 3 4 5 6 from django.contrib.auth.models import AbstractBaseUser class CustomUserModel ( AbstractBaseUser ): @property def is_really_cool ( self ): return True ... then you would do the following within your decorator: components.py 1 2 3 4 5 6 7 8 from django_idom.decorators import auth_required from django_idom.hooks import use_websocket from idom import component , html @component @auth_required ( auth_attribute = \"is_really_cool\" ) def my_component (): return html . div ( \"I am logged in!\" )","title":"Auth Required"},{"location":"features/hooks/","text":"Summary Prefabricated hooks can be used within your components.py to help simplify development. Looking for standard ReactJS hooks? Standard ReactJS hooks are contained within idom-team/idom . Since idom is installed by default alongside django-idom , you can import them at any time. Check out the IDOM Core docs to see what hooks are available! Use Query \u00b6 The use_query hook is used fetch Django ORM queries. The function you provide into this hook must return either a Model or QuerySet . components.py models.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from example_project.my_app.models import TodoItem from idom import component , html from django_idom.hooks import use_query def get_items (): return TodoItem . objects . all () @component def todo_list (): item_query = use_query ( get_items ) if item_query . loading : rendered_items = html . h2 ( \"Loading...\" ) elif item_query . error : rendered_items = html . h2 ( \"Error when loading!\" ) else : rendered_items = html . ul ( html . li ( item , key = item ) for item in item_query . data ) return rendered_items 1 2 3 4 from django.db import models class TodoItem ( models . Model ): text = models . CharField ( max_length = 255 ) See Interface Parameters Name Type Description Default query Callable[_Params, _Result | None] A callable that returns a Django Model or QuerySet . N/A *args _Params.args Positional arguments to pass into query . N/A **kwargs _Params.kwargs Keyword arguments to pass into query . N/A Returns Type Description Query[_Result | None] An object containing loading / error states, your data (if the query has successfully executed), and a refetch callable that can be used to re-run the query. Can I make ORM calls without hooks? Due to Django's ORM design, database queries must be deferred using hooks. Otherwise, you will see a SynchronousOnlyOperation exception. This may be resolved in a future version of Django containing an asynchronous ORM. Why does the example get_items function return a Model or QuerySet ? This was a technical design decision to based on Apollo , but ultimately helps avoid Django's SynchronousOnlyOperation exceptions. The use_query hook ensures the provided Model or QuerySet executes all deferred / lazy queries safely prior to reaching your components. What is an \"ORM\"? A Python Object Relational Mapper is an API for your code to access a database. See the Django ORM documentation for more information. Use Mutation \u00b6 The use_mutation hook is used to create, update, or delete Django ORM objects. The function you provide into this hook will have no return value. components.py models.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from example_project.my_app.models import TodoItem from idom import component , html from django_idom.hooks import use_mutation def add_item ( text : str ): TodoItem ( text = text ) . save () @component def todo_list (): def submit_event ( event ): if event [ \"key\" ] == \"Enter\" : item_mutation . execute ( text = event [ \"target\" ][ \"value\" ]) item_mutation = use_mutation ( add_item ) if item_mutation . loading : mutation_status = html . h2 ( \"Adding...\" ) elif item_mutation . error : mutation_status = html . h2 ( \"Error when adding!\" ) else : mutation_status = \"\" return html . div ( html . label ( \"Add an item:\" ), html . input ({ \"type\" : \"text\" , \"onKeyDown\" : submit_event }), mutation_status , ) 1 2 3 4 from django.db import models class TodoItem ( models . Model ): text = models . CharField ( max_length = 255 ) See Interface Parameters Name Type Description Default mutate Callable[_Params, bool | None] A callable that performs Django ORM create, update, or delete functionality. If this function returns False , then your refetch function will not be used. N/A refetch Callable[..., Any] | Sequence[Callable[..., Any]] | None A query function (used by the use_query hook) or a sequence of query functions that will be called if the mutation succeeds. This is useful for refetching data after a mutation has been performed. None Returns Type Description Mutation[_Params] An object containing loading / error states, a reset callable that will set loading / error states to defaults, and a execute callable that will run the query. Can use_mutation trigger a refetch of use_query ? Yes, use_mutation can queue a refetch of a use_query via the refetch=... argument. The example below is a merge of the use_query and use_mutation examples above with the addition of a refetch argument on use_mutation . Please note that any use_query hooks that use get_items will be refetched upon a successful mutation. components.py models.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 from example_project.my_app.models import TodoItem from idom import component , html from django_idom.hooks import use_mutation def get_items (): return TodoItem . objects . all () def add_item ( text : str ): TodoItem ( text = text ) . save () @component def todo_list (): def submit_event ( event ): if event [ \"key\" ] == \"Enter\" : item_mutation . execute ( text = event [ \"target\" ][ \"value\" ]) item_query = use_query ( get_items ) if item_query . loading : rendered_items = html . h2 ( \"Loading...\" ) elif item_query . error : rendered_items = html . h2 ( \"Error when loading!\" ) else : rendered_items = html . ul ( html . li ( item , key = item ) for item in item_query . data ) item_mutation = use_mutation ( add_item , refetch = get_items ) if item_mutation . loading : mutation_status = html . h2 ( \"Adding...\" ) elif item_mutation . error : mutation_status = html . h2 ( \"Error when adding!\" ) else : mutation_status = \"\" return html . div ( html . label ( \"Add an item:\" ), html . input ({ \"type\" : \"text\" , \"onKeyDown\" : submit_event }), mutation_status , rendered_items , ) 1 2 3 4 from django.db import models class TodoItem ( models . Model ): text = models . CharField ( max_length = 255 ) Can I make a failed use_mutation try again? Yes, a use_mutation can be re-performed by calling reset() on your use_mutation instance. For example, take a look at reset_event below. components.py models.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 from example_project.my_app.models import TodoItem from idom import component , html from django_idom.hooks import use_mutation def add_item ( text : str ): TodoItem ( text = text ) . save () @component def todo_list (): def reset_event ( event ): item_mutation . reset () def submit_event ( event ): if event [ \"key\" ] == \"Enter\" : item_mutation . execute ( text = event [ \"target\" ][ \"value\" ]) item_mutation = use_mutation ( add_item ) if item_mutation . loading : mutation_status = html . h2 ( \"Adding...\" ) elif item_mutation . error : mutation_status = html . button ({ \"onClick\" : reset_event }, \"Error: Try again!\" ) else : mutation_status = \"\" return html . div ( html . label ( \"Add an item:\" ), html . input ({ \"type\" : \"text\" , \"onKeyDown\" : submit_event }), mutation_status , ) 1 2 3 4 from django.db import models class TodoItem ( models . Model ): text = models . CharField ( max_length = 255 ) Can I make ORM calls without hooks? Due to Django's ORM design, database queries must be deferred using hooks. Otherwise, you will see a SynchronousOnlyOperation exception. This may be resolved in a future version of Django containing an asynchronous ORM. However, even when resolved it is best practice to perform ORM queries within the use_query in order to handle loading and error states. What is an \"ORM\"? A Python Object Relational Mapper is an API for your code to access a database. See the Django ORM documentation for more information. Use Websocket \u00b6 You can fetch the Django Channels websocket at any time by using use_websocket . components.py 1 2 3 4 5 6 7 from idom import component , html from django_idom.hooks import use_websocket @component def my_component (): my_websocket = use_websocket () return html . div ( my_websocket ) See Interface Parameters None Returns Type Description IdomWebsocket The component's websocket. Use Scope \u00b6 This is a shortcut that returns the Websocket's scope . components.py 1 2 3 4 5 6 7 from idom import component , html from django_idom.hooks import use_scope @component def my_component (): my_scope = use_scope () return html . div ( my_scope ) See Interface Parameters None Returns Type Description dict[str, Any] The websocket's scope . Use Location \u00b6 This is a shortcut that returns the Websocket's path . You can expect this hook to provide strings such as /idom/my_path . components.py 1 2 3 4 5 6 7 from idom import component , html from django_idom.hooks import use_location @component def my_component (): my_location = use_location () return html . div ( my_location ) See Interface Parameters None Returns Type Description Location A object containing the current URL's pathname and search query. This hook's behavior will be changed in a future update This hook will be updated to return the browser's currently active path. This change will come in alongside IDOM URL routing support. Check out idom-team/idom-router#2 for more information. Use Origin \u00b6 This is a shortcut that returns the Websocket's origin . You can expect this hook to provide strings such as http://example.com . components.py 1 2 3 4 5 6 7 from idom import component , html from django_idom.hooks import use_origin @component def my_component (): my_origin = use_origin () return html . div ( my_origin ) See Interface Parameters None Returns Type Description str | None A string containing the browser's current origin, obtained from websocket headers (if available).","title":"Hooks"},{"location":"features/hooks/#use-query","text":"The use_query hook is used fetch Django ORM queries. The function you provide into this hook must return either a Model or QuerySet . components.py models.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from example_project.my_app.models import TodoItem from idom import component , html from django_idom.hooks import use_query def get_items (): return TodoItem . objects . all () @component def todo_list (): item_query = use_query ( get_items ) if item_query . loading : rendered_items = html . h2 ( \"Loading...\" ) elif item_query . error : rendered_items = html . h2 ( \"Error when loading!\" ) else : rendered_items = html . ul ( html . li ( item , key = item ) for item in item_query . data ) return rendered_items 1 2 3 4 from django.db import models class TodoItem ( models . Model ): text = models . CharField ( max_length = 255 ) See Interface Parameters Name Type Description Default query Callable[_Params, _Result | None] A callable that returns a Django Model or QuerySet . N/A *args _Params.args Positional arguments to pass into query . N/A **kwargs _Params.kwargs Keyword arguments to pass into query . N/A Returns Type Description Query[_Result | None] An object containing loading / error states, your data (if the query has successfully executed), and a refetch callable that can be used to re-run the query. Can I make ORM calls without hooks? Due to Django's ORM design, database queries must be deferred using hooks. Otherwise, you will see a SynchronousOnlyOperation exception. This may be resolved in a future version of Django containing an asynchronous ORM. Why does the example get_items function return a Model or QuerySet ? This was a technical design decision to based on Apollo , but ultimately helps avoid Django's SynchronousOnlyOperation exceptions. The use_query hook ensures the provided Model or QuerySet executes all deferred / lazy queries safely prior to reaching your components. What is an \"ORM\"? A Python Object Relational Mapper is an API for your code to access a database. See the Django ORM documentation for more information.","title":"Use Query"},{"location":"features/hooks/#use-mutation","text":"The use_mutation hook is used to create, update, or delete Django ORM objects. The function you provide into this hook will have no return value. components.py models.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from example_project.my_app.models import TodoItem from idom import component , html from django_idom.hooks import use_mutation def add_item ( text : str ): TodoItem ( text = text ) . save () @component def todo_list (): def submit_event ( event ): if event [ \"key\" ] == \"Enter\" : item_mutation . execute ( text = event [ \"target\" ][ \"value\" ]) item_mutation = use_mutation ( add_item ) if item_mutation . loading : mutation_status = html . h2 ( \"Adding...\" ) elif item_mutation . error : mutation_status = html . h2 ( \"Error when adding!\" ) else : mutation_status = \"\" return html . div ( html . label ( \"Add an item:\" ), html . input ({ \"type\" : \"text\" , \"onKeyDown\" : submit_event }), mutation_status , ) 1 2 3 4 from django.db import models class TodoItem ( models . Model ): text = models . CharField ( max_length = 255 ) See Interface Parameters Name Type Description Default mutate Callable[_Params, bool | None] A callable that performs Django ORM create, update, or delete functionality. If this function returns False , then your refetch function will not be used. N/A refetch Callable[..., Any] | Sequence[Callable[..., Any]] | None A query function (used by the use_query hook) or a sequence of query functions that will be called if the mutation succeeds. This is useful for refetching data after a mutation has been performed. None Returns Type Description Mutation[_Params] An object containing loading / error states, a reset callable that will set loading / error states to defaults, and a execute callable that will run the query. Can use_mutation trigger a refetch of use_query ? Yes, use_mutation can queue a refetch of a use_query via the refetch=... argument. The example below is a merge of the use_query and use_mutation examples above with the addition of a refetch argument on use_mutation . Please note that any use_query hooks that use get_items will be refetched upon a successful mutation. components.py models.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 from example_project.my_app.models import TodoItem from idom import component , html from django_idom.hooks import use_mutation def get_items (): return TodoItem . objects . all () def add_item ( text : str ): TodoItem ( text = text ) . save () @component def todo_list (): def submit_event ( event ): if event [ \"key\" ] == \"Enter\" : item_mutation . execute ( text = event [ \"target\" ][ \"value\" ]) item_query = use_query ( get_items ) if item_query . loading : rendered_items = html . h2 ( \"Loading...\" ) elif item_query . error : rendered_items = html . h2 ( \"Error when loading!\" ) else : rendered_items = html . ul ( html . li ( item , key = item ) for item in item_query . data ) item_mutation = use_mutation ( add_item , refetch = get_items ) if item_mutation . loading : mutation_status = html . h2 ( \"Adding...\" ) elif item_mutation . error : mutation_status = html . h2 ( \"Error when adding!\" ) else : mutation_status = \"\" return html . div ( html . label ( \"Add an item:\" ), html . input ({ \"type\" : \"text\" , \"onKeyDown\" : submit_event }), mutation_status , rendered_items , ) 1 2 3 4 from django.db import models class TodoItem ( models . Model ): text = models . CharField ( max_length = 255 ) Can I make a failed use_mutation try again? Yes, a use_mutation can be re-performed by calling reset() on your use_mutation instance. For example, take a look at reset_event below. components.py models.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 from example_project.my_app.models import TodoItem from idom import component , html from django_idom.hooks import use_mutation def add_item ( text : str ): TodoItem ( text = text ) . save () @component def todo_list (): def reset_event ( event ): item_mutation . reset () def submit_event ( event ): if event [ \"key\" ] == \"Enter\" : item_mutation . execute ( text = event [ \"target\" ][ \"value\" ]) item_mutation = use_mutation ( add_item ) if item_mutation . loading : mutation_status = html . h2 ( \"Adding...\" ) elif item_mutation . error : mutation_status = html . button ({ \"onClick\" : reset_event }, \"Error: Try again!\" ) else : mutation_status = \"\" return html . div ( html . label ( \"Add an item:\" ), html . input ({ \"type\" : \"text\" , \"onKeyDown\" : submit_event }), mutation_status , ) 1 2 3 4 from django.db import models class TodoItem ( models . Model ): text = models . CharField ( max_length = 255 ) Can I make ORM calls without hooks? Due to Django's ORM design, database queries must be deferred using hooks. Otherwise, you will see a SynchronousOnlyOperation exception. This may be resolved in a future version of Django containing an asynchronous ORM. However, even when resolved it is best practice to perform ORM queries within the use_query in order to handle loading and error states. What is an \"ORM\"? A Python Object Relational Mapper is an API for your code to access a database. See the Django ORM documentation for more information.","title":"Use Mutation"},{"location":"features/hooks/#use-websocket","text":"You can fetch the Django Channels websocket at any time by using use_websocket . components.py 1 2 3 4 5 6 7 from idom import component , html from django_idom.hooks import use_websocket @component def my_component (): my_websocket = use_websocket () return html . div ( my_websocket ) See Interface Parameters None Returns Type Description IdomWebsocket The component's websocket.","title":"Use Websocket"},{"location":"features/hooks/#use-scope","text":"This is a shortcut that returns the Websocket's scope . components.py 1 2 3 4 5 6 7 from idom import component , html from django_idom.hooks import use_scope @component def my_component (): my_scope = use_scope () return html . div ( my_scope ) See Interface Parameters None Returns Type Description dict[str, Any] The websocket's scope .","title":"Use Scope"},{"location":"features/hooks/#use-location","text":"This is a shortcut that returns the Websocket's path . You can expect this hook to provide strings such as /idom/my_path . components.py 1 2 3 4 5 6 7 from idom import component , html from django_idom.hooks import use_location @component def my_component (): my_location = use_location () return html . div ( my_location ) See Interface Parameters None Returns Type Description Location A object containing the current URL's pathname and search query. This hook's behavior will be changed in a future update This hook will be updated to return the browser's currently active path. This change will come in alongside IDOM URL routing support. Check out idom-team/idom-router#2 for more information.","title":"Use Location"},{"location":"features/hooks/#use-origin","text":"This is a shortcut that returns the Websocket's origin . You can expect this hook to provide strings such as http://example.com . components.py 1 2 3 4 5 6 7 from idom import component , html from django_idom.hooks import use_origin @component def my_component (): my_origin = use_origin () return html . div ( my_origin ) See Interface Parameters None Returns Type Description str | None A string containing the browser's current origin, obtained from websocket headers (if available).","title":"Use Origin"},{"location":"features/settings/","text":"Summary Django-IDOM uses your Django project's settings.py file to modify the behavior of IDOM. Primary Configuration \u00b6 settings.py 1 2 3 4 5 6 7 8 9 10 11 # If \"idom\" cache is not configured, then we will use \"default\" instead CACHES = { \"idom\" : { \"BACKEND\" : ... }, } # Maximum seconds between two reconnection attempts that would cause the client give up. # 0 will disable reconnection. IDOM_WS_MAX_RECONNECT_TIMEOUT = 604800 # The URL for IDOM to serve websockets IDOM_WEBSOCKET_URL = \"idom/\" Do I need to modify my settings? The default configuration of IDOM is adequate for the majority of use cases. You should only consider changing settings when the necessity arises.","title":"Settings"},{"location":"features/settings/#primary-configuration","text":"settings.py 1 2 3 4 5 6 7 8 9 10 11 # If \"idom\" cache is not configured, then we will use \"default\" instead CACHES = { \"idom\" : { \"BACKEND\" : ... }, } # Maximum seconds between two reconnection attempts that would cause the client give up. # 0 will disable reconnection. IDOM_WS_MAX_RECONNECT_TIMEOUT = 604800 # The URL for IDOM to serve websockets IDOM_WEBSOCKET_URL = \"idom/\" Do I need to modify my settings? The default configuration of IDOM is adequate for the majority of use cases. You should only consider changing settings when the necessity arises.","title":"Primary Configuration"},{"location":"features/templatetag/","text":"Summary Template tags can be used within your Django templates such as my-template.html to import IDOM features. Component \u00b6 my-template.html 1 2 3 4 5 6 7 {% load idom %} <!DOCTYPE html> <html> <body> {% component \"example_project.my_app.components.hello_world\" recipient = \"World\" %} </body> </html> Do not use context variables for the IDOM component name Our pre-processor relies on the template tag containing a string. Do not use Django template/context variables for the component path. Failure to follow this warning will result in unexpected behavior. For example, do not do the following: my-template.html views.py 1 2 3 4 5 <!-- This is bad --> {% component dont_do_this recipient = \"World\" %} <!-- This is good --> {% component \"example_project.my_app.components.hello_world\" recipient = \"World\" %} 1 2 3 def example_view (): context_vars = { \"dont_do_this\" : \"example_project.my_app.components.hello_world\" } return render ( request , \"my-template.html\" , context_vars ) Reserved keyword arguments: class and key For this template tag, there are two reserved keyword arguments: class and key class allows you to apply a HTML class to the top-level component div. This is useful for styling purposes. key allows you to force the component to use a specific key value . You typically won't need to set this. my-template.html 1 2 3 ... {% component \"example.components.my_component\" class = \"my-html-class\" key = 123 %} ... See Interface Parameters Name Type Description Default dotted_path str The dotted path to the component to render. N/A **kwargs Any The keyword arguments to pass to the component. N/A Returns Type Description Component An IDOM component. Can I use multiple components on one page? You can add as many components to a webpage as needed by using the template tag multiple times. Retrofitting legacy sites to use IDOM will typically involve many components on one page. my-template.html 1 2 3 4 5 6 7 8 9 {% load idom %} <!DOCTYPE html> <html> <body> {% component \"example_project.my_app.components.hello_world\" recipient = \"World\" %} {% component \"example_project.my_app_2.components.class_component\" class = \"bold small-font\" %} <div> {% component \"example_project.my_app_3.components.simple_component\" %} </div> </body> </html> But keep in mind, in scenarios where you are trying to create a Single Page Application (SPA) within Django, you will only have one central component within your < body > tag. Additionally, the components in the example above will not be able to interact with each other, except through database queries. Can I use positional arguments instead of keyword arguments? You can only pass in keyword arguments within the template tag. Due to technical limitations, positional arguments are not supported at this time. What is a \"template tag\"? You can think of template tags as Django's way of allowing you to run Python code within your HTML. Django-IDOM uses a {% component ... %} template tag to perform it's magic. Keep in mind, in order to use the {% component ... %} tag, you will need to first call {% load idom %} to gain access to it. my-template.html 1 2 3 4 5 6 7 {% load idom %} <!DOCTYPE html> <html> <body> {% component \"example_project.my_app.components.hello_world\" recipient = \"World\" %} </body> </html>","title":"Template Tag"},{"location":"features/templatetag/#component","text":"my-template.html 1 2 3 4 5 6 7 {% load idom %} <!DOCTYPE html> <html> <body> {% component \"example_project.my_app.components.hello_world\" recipient = \"World\" %} </body> </html> Do not use context variables for the IDOM component name Our pre-processor relies on the template tag containing a string. Do not use Django template/context variables for the component path. Failure to follow this warning will result in unexpected behavior. For example, do not do the following: my-template.html views.py 1 2 3 4 5 <!-- This is bad --> {% component dont_do_this recipient = \"World\" %} <!-- This is good --> {% component \"example_project.my_app.components.hello_world\" recipient = \"World\" %} 1 2 3 def example_view (): context_vars = { \"dont_do_this\" : \"example_project.my_app.components.hello_world\" } return render ( request , \"my-template.html\" , context_vars ) Reserved keyword arguments: class and key For this template tag, there are two reserved keyword arguments: class and key class allows you to apply a HTML class to the top-level component div. This is useful for styling purposes. key allows you to force the component to use a specific key value . You typically won't need to set this. my-template.html 1 2 3 ... {% component \"example.components.my_component\" class = \"my-html-class\" key = 123 %} ... See Interface Parameters Name Type Description Default dotted_path str The dotted path to the component to render. N/A **kwargs Any The keyword arguments to pass to the component. N/A Returns Type Description Component An IDOM component. Can I use multiple components on one page? You can add as many components to a webpage as needed by using the template tag multiple times. Retrofitting legacy sites to use IDOM will typically involve many components on one page. my-template.html 1 2 3 4 5 6 7 8 9 {% load idom %} <!DOCTYPE html> <html> <body> {% component \"example_project.my_app.components.hello_world\" recipient = \"World\" %} {% component \"example_project.my_app_2.components.class_component\" class = \"bold small-font\" %} <div> {% component \"example_project.my_app_3.components.simple_component\" %} </div> </body> </html> But keep in mind, in scenarios where you are trying to create a Single Page Application (SPA) within Django, you will only have one central component within your < body > tag. Additionally, the components in the example above will not be able to interact with each other, except through database queries. Can I use positional arguments instead of keyword arguments? You can only pass in keyword arguments within the template tag. Due to technical limitations, positional arguments are not supported at this time. What is a \"template tag\"? You can think of template tags as Django's way of allowing you to run Python code within your HTML. Django-IDOM uses a {% component ... %} template tag to perform it's magic. Keep in mind, in order to use the {% component ... %} tag, you will need to first call {% load idom %} to gain access to it. my-template.html 1 2 3 4 5 6 7 {% load idom %} <!DOCTYPE html> <html> <body> {% component \"example_project.my_app.components.hello_world\" recipient = \"World\" %} </body> </html>","title":"Component"},{"location":"getting-started/choose-django-app/","text":"Summary Set up a Django Project with at least one app. If you have reached this point, you should have already installed Django-IDOM through the previous steps. You will now need to pick at least one Django app to start using Django-IDOM on. For the examples within this section, we will assume you have placed the files generated by startapp directly into your Django project folder. This is common for small projects. How do I organize my Django project for IDOM? Django-IDOM has no project structure requirements. Organize everything as you wish, just like any Django project .","title":"2. Choose a Django App"},{"location":"getting-started/create-component/","text":"Summary Create a component function using our decorator. You will need a file to define your IDOM components. We recommend creating a components.py file within your chosen Django app to start out. Within this file, we will create a simple hello_world component. components.py 1 2 3 4 5 from idom import component , html @component def hello_world ( recipient : str ): return html . h1 ( f \"Hello { recipient } !\" ) What should I name my IDOM files and functions? You have full freedom in naming/placement of your files and functions. We recommend creating a components.py for small Django apps . If your app has a lot of components, you should consider breaking them apart into individual modules such as components/navbar.py . Ultimately, components are referenced by Python dotted path in my-template.html ( see next step ). So, at minimum this path needs to be valid to Python's importlib .","title":"3. Create a Component"},{"location":"getting-started/installation/","text":"Summary Django-IDOM can be installed from PyPI to an existing Django project with minimal configuration. Step 0: Set up a Django Project \u00b6 These docs assumes you have already created a Django project , which involves creating and installing at least one Django app . If not, check out this 9 minute YouTube tutorial created by IDG TECHtalk . Step 1: Install from PyPI \u00b6 pip install django-idom Step 2: Configure settings.py \u00b6 In your settings you will need to add django_idom to INSTALLED_APPS . settings.py 1 2 3 4 INSTALLED_APPS = [ \"django_idom\" , ... ] Enable Django ASGI (Required) Django-IDOM requires ASGI in order to use Websockets. If you have not enabled ASGI on your Django project yet, you will need to install channels[daphne] , add daphne to INSTALLED_APPS , then set your ASGI_APPLICATION variable. Read the Django Channels Docs for more info. settings.py 1 2 3 4 5 INSTALLED_APPS = [ \"daphne\" , ... ] ASGI_APPLICATION = \"example_project.asgi.application\" Configure IDOM settings (Optional) Below are a handful of values you can change within settings.py to modify the behavior of IDOM. 1 2 3 4 5 6 7 8 9 10 11 # If \"idom\" cache is not configured, then we will use \"default\" instead CACHES = { \"idom\" : { \"BACKEND\" : ... }, } # Maximum seconds between two reconnection attempts that would cause the client give up. # 0 will disable reconnection. IDOM_WS_MAX_RECONNECT_TIMEOUT = 604800 # The URL for IDOM to serve websockets IDOM_WEBSOCKET_URL = \"idom/\" Step 3: Configure urls.py \u00b6 Add IDOM HTTP paths to your urlpatterns . urls.py 1 2 3 4 5 6 from django.urls import include , path urlpatterns = [ path ( \"idom/\" , include ( \"django_idom.http.urls\" )), ... ] Step 4: Configure asgi.py \u00b6 Register IDOM's Websocket using IDOM_WEBSOCKET_PATH . asgi.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import os from django.core.asgi import get_asgi_application # Ensure DJANGO_SETTINGS_MODULE is set properly based on your project name! os . environ . setdefault ( \"DJANGO_SETTINGS_MODULE\" , \"example_project.settings\" ) django_asgi_app = get_asgi_application () from channels.auth import AuthMiddlewareStack from channels.routing import ProtocolTypeRouter , URLRouter from channels.sessions import SessionMiddlewareStack from django_idom import IDOM_WEBSOCKET_PATH application = ProtocolTypeRouter ( { \"http\" : django_asgi_app , \"websocket\" : SessionMiddlewareStack ( AuthMiddlewareStack ( URLRouter ([ IDOM_WEBSOCKET_PATH ])) ), } ) Where is my asgi.py ? If you do not have an asgi.py , follow the channels installation guide .","title":"1. Install Django-IDOM"},{"location":"getting-started/installation/#step-0-set-up-a-django-project","text":"These docs assumes you have already created a Django project , which involves creating and installing at least one Django app . If not, check out this 9 minute YouTube tutorial created by IDG TECHtalk .","title":"Step 0: Set up a Django Project"},{"location":"getting-started/installation/#step-1-install-from-pypi","text":"pip install django-idom","title":"Step 1: Install from PyPI"},{"location":"getting-started/installation/#step-2-configure-settingspy","text":"In your settings you will need to add django_idom to INSTALLED_APPS . settings.py 1 2 3 4 INSTALLED_APPS = [ \"django_idom\" , ... ] Enable Django ASGI (Required) Django-IDOM requires ASGI in order to use Websockets. If you have not enabled ASGI on your Django project yet, you will need to install channels[daphne] , add daphne to INSTALLED_APPS , then set your ASGI_APPLICATION variable. Read the Django Channels Docs for more info. settings.py 1 2 3 4 5 INSTALLED_APPS = [ \"daphne\" , ... ] ASGI_APPLICATION = \"example_project.asgi.application\" Configure IDOM settings (Optional) Below are a handful of values you can change within settings.py to modify the behavior of IDOM. 1 2 3 4 5 6 7 8 9 10 11 # If \"idom\" cache is not configured, then we will use \"default\" instead CACHES = { \"idom\" : { \"BACKEND\" : ... }, } # Maximum seconds between two reconnection attempts that would cause the client give up. # 0 will disable reconnection. IDOM_WS_MAX_RECONNECT_TIMEOUT = 604800 # The URL for IDOM to serve websockets IDOM_WEBSOCKET_URL = \"idom/\"","title":"Step 2: Configure settings.py"},{"location":"getting-started/installation/#step-3-configure-urlspy","text":"Add IDOM HTTP paths to your urlpatterns . urls.py 1 2 3 4 5 6 from django.urls import include , path urlpatterns = [ path ( \"idom/\" , include ( \"django_idom.http.urls\" )), ... ]","title":"Step 3: Configure urls.py"},{"location":"getting-started/installation/#step-4-configure-asgipy","text":"Register IDOM's Websocket using IDOM_WEBSOCKET_PATH . asgi.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import os from django.core.asgi import get_asgi_application # Ensure DJANGO_SETTINGS_MODULE is set properly based on your project name! os . environ . setdefault ( \"DJANGO_SETTINGS_MODULE\" , \"example_project.settings\" ) django_asgi_app = get_asgi_application () from channels.auth import AuthMiddlewareStack from channels.routing import ProtocolTypeRouter , URLRouter from channels.sessions import SessionMiddlewareStack from django_idom import IDOM_WEBSOCKET_PATH application = ProtocolTypeRouter ( { \"http\" : django_asgi_app , \"websocket\" : SessionMiddlewareStack ( AuthMiddlewareStack ( URLRouter ([ IDOM_WEBSOCKET_PATH ])) ), } ) Where is my asgi.py ? If you do not have an asgi.py , follow the channels installation guide .","title":"Step 4: Configure asgi.py"},{"location":"getting-started/learn-more/","text":"Congratulations \u00b6 If you followed the previous steps, you have now created a \"Hello World\" component! The docs you are reading only covers our Django integration. To learn more about features, such as interactive events and hooks, check out the IDOM Core Documentation ! Additionally, the vast majority of tutorials/guides you find for React can be applied to IDOM. Learn More Django-IDOM Advanced Usage IDOM Core Documentation Ask Questions on GitHub Discussions","title":"6. Learn More"},{"location":"getting-started/learn-more/#congratulations","text":"If you followed the previous steps, you have now created a \"Hello World\" component! The docs you are reading only covers our Django integration. To learn more about features, such as interactive events and hooks, check out the IDOM Core Documentation ! Additionally, the vast majority of tutorials/guides you find for React can be applied to IDOM. Learn More Django-IDOM Advanced Usage IDOM Core Documentation Ask Questions on GitHub Discussions","title":"Congratulations"},{"location":"getting-started/reference-component/","text":"Summary Decide where the component will be displayed by using our template tag. In your Django app 's HTML template, you can now embed your IDOM component using the component template tag. Within this tag, you will need to type in your dotted path to the component function as the first argument. Additionally, you can pass in keyword arguments into your component function. For example, after reading the code below, pay attention to how the function definition for hello_world ( in the previous example ) accepts a recipient argument. my-template.html 1 2 3 4 5 6 7 {% load idom %} <!DOCTYPE html> <html> <body> {% component \"example_project.my_app.components.hello_world\" recipient = \"World\" %} </body> </html> Do not use context variables for the IDOM component name Our pre-processor relies on the template tag containing a string. Do not use Django template/context variables for the component path. Failure to follow this warning will result in unexpected behavior. For example, do not do the following: my-template.html views.py 1 2 3 4 5 <!-- This is bad --> {% component dont_do_this recipient = \"World\" %} <!-- This is good --> {% component \"example_project.my_app.components.hello_world\" recipient = \"World\" %} 1 2 3 def example_view (): context_vars = { \"dont_do_this\" : \"example_project.my_app.components.hello_world\" } return render ( request , \"my-template.html\" , context_vars ) Reserved keyword arguments: class and key For this template tag, there are two reserved keyword arguments: class and key class allows you to apply a HTML class to the top-level component div. This is useful for styling purposes. key allows you to force the component to use a specific key value . You typically won't need to set this. my-template.html 1 2 3 ... {% component \"example.components.my_component\" class = \"my-html-class\" key = 123 %} ... Can I use multiple components on one page? You can add as many components to a webpage as needed by using the template tag multiple times. Retrofitting legacy sites to use IDOM will typically involve many components on one page. my-template.html 1 2 3 4 5 6 7 8 9 {% load idom %} <!DOCTYPE html> <html> <body> {% component \"example_project.my_app.components.hello_world\" recipient = \"World\" %} {% component \"example_project.my_app_2.components.class_component\" class = \"bold small-font\" %} <div> {% component \"example_project.my_app_3.components.simple_component\" %} </div> </body> </html> But keep in mind, in scenarios where you are trying to create a Single Page Application (SPA) within Django, you will only have one central component within your < body > tag. Additionally, the components in the example above will not be able to interact with each other, except through database queries. Can I use positional arguments instead of keyword arguments? You can only pass in keyword arguments within the template tag. Due to technical limitations, positional arguments are not supported at this time. What is a \"template tag\"? You can think of template tags as Django's way of allowing you to run Python code within your HTML. Django-IDOM uses a {% component ... %} template tag to perform it's magic. Keep in mind, in order to use the {% component ... %} tag, you will need to first call {% load idom %} to gain access to it. my-template.html 1 2 3 4 5 6 7 {% load idom %} <!DOCTYPE html> <html> <body> {% component \"example_project.my_app.components.hello_world\" recipient = \"World\" %} </body> </html> Where is my templates folder? If you do not have a templates folder in your Django app , you can simply create one! Keep in mind, templates within this folder will not be detected by Django unless you add the corresponding Django app to settings.py:INSTALLED_APPS .","title":"4. Use the Template Tag"},{"location":"getting-started/render-view/","text":"Summary Select your template containing an IDOM component, and render it using a Django view. We will assume you have created a Django View before, but here's a simple example below. Within your Django app 's views.py file, you will need to create a function to render the HTML template containing your IDOM components. In this example, we will create a view that renders my-template.html ( from the previous step ). views.py 1 2 3 4 from django.shortcuts import render def index ( request ): return render ( request , \"my-template.html\" ) We will add this new view into your urls.py . urls.py 1 2 3 4 5 6 from django.urls import path from example_project.my_app import views urlpatterns = [ path ( \"example/\" , views . index ), ] Now, navigate to http://127.0.0.1:8000/example/ . If you copy-pasted the component from the previous example, you will now see your component display \"Hello World\". Which urls.py do I add my views to? For simple Django projects , you can easily add all of your views directly into the Django project's urls.py . However, as you start increase your project's complexity you might end up with way too much within one file. Once you reach that point, we recommend creating an individual urls.py within each of your Django apps . Then, within your Django project's urls.py you will use Django's include function to link it all together.","title":"5. Render Your View"}]}