{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#reactpy-django","title":"ReactPy Django","text":"<p>ReactPy-Django is used to add used to add ReactPy support to an existing Django project.</p> <p>ReactPy is a library for building user interfaces in Python without Javascript. ReactPy interfaces are made from components that look and behave similar to those found in ReactJS. Designed with simplicity in mind, ReactPy can be used by those without web development experience while also being powerful enough to grow with your ambitions.</p> Supported Backends Built-in External                  Flask, FastAPI, Sanic, Tornado              Django,             Jupyter,             Plotly-Dash"},{"location":"#resources","title":"Resources","text":"<p>Follow the links below to find out more about this project.</p> <ul> <li>Try ReactPy (Jupyter Notebook)</li> <li>Documentation</li> <li>GitHub Discussions</li> <li>Discord</li> <li>Contributor Guide</li> <li>Code of Conduct</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>      The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.     </p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>More customization for reconnection behavior through new settings!<ul> <li><code>REACTPY_RECONNECT_INTERVAL</code></li> <li><code>REACTPY_RECONNECT_MAX_INTERVAL</code></li> <li><code>REACTPY_RECONNECT_MAX_RETRIES</code></li> <li><code>REACTPY_RECONNECT_BACKOFF_MULTIPLIER</code></li> </ul> </li> <li>ReactPy-Django docs are now version controlled via mike!</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Bumped the minimum ReactPy version to <code>1.0.2</code>.</li> <li>Prettier websocket URLs for components that do not have sessions.</li> <li>Template tag will now only validate <code>args</code>/<code>kwargs</code> if <code>settings.py:DEBUG</code> is enabled.</li> <li>Bumped the minimum <code>@reactpy/client</code> version to <code>0.3.1</code></li> <li>Use TypeScript instead of JavaScript for this repository.</li> <li>Bumped minimum Django version to <code>4.2</code>.<ul> <li>Note: ReactPy-Django will continue bumping minimum Django requirements to versions that increase async support. This \"latest-only\" trend will continue until Django has all async features that ReactPy benefits from. After this point, ReactPy-Django will begin supporting all maintained Django versions.</li> </ul> </li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li><code>settings.py:REACTPY_RECONNECT_MAX</code> is removed. See the docs for the new <code>REACTPY_RECONNECT_*</code> settings.</li> </ul>"},{"location":"changelog/#340-2023-08-18","title":"3.4.0 - 2023-08-18","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Distributed Computing: ReactPy components can now optionally be rendered by a completely separate server!<ul> <li><code>REACTPY_DEFAULT_HOSTS</code> setting can round-robin a list of ReactPy rendering hosts.</li> <li><code>host</code> argument has been added to the <code>component</code> template tag to force components to render on a specific host.</li> </ul> </li> <li><code>reactpy_django.utils.register_component</code> function can manually register root components.<ul> <li>Useful if you have dedicated ReactPy rendering application(s) that do not use HTML templates.</li> </ul> </li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>ReactPy will now provide a warning if your HTTP URLs are not on the same prefix as your websockets.</li> <li>Cleaner logging output for auto-detected ReactPy root components.</li> </ul>"},{"location":"changelog/#deprecated","title":"Deprecated","text":"<ul> <li><code>reactpy_django.REACTPY_WEBSOCKET_PATH</code> is deprecated. The identical replacement is <code>REACTPY_WEBSOCKET_ROUTE</code>.</li> <li><code>settings.py:REACTPY_WEBSOCKET_URL</code> is deprecated. The similar replacement is <code>REACTPY_URL_PREFIX</code>.</li> </ul>"},{"location":"changelog/#removed_1","title":"Removed","text":"<ul> <li>Warning W007 (<code>REACTPY_WEBSOCKET_URL doesn't end with a slash</code>) has been removed. ReactPy now automatically handles slashes.</li> <li>Warning W008 (<code>REACTPY_WEBSOCKET_URL doesn't start with an alphanumeric character</code>) has been removed. ReactPy now automatically handles this scenario.</li> <li>Error E009 (<code>channels is not in settings.py:INSTALLED_APPS</code>) has been removed. Newer versions of <code>channels</code> do not require installation via <code>INSTALLED_APPS</code> to receive an ASGI webserver.</li> </ul>"},{"location":"changelog/#332-2023-08-13","title":"3.3.2 - 2023-08-13","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>ReactPy Websocket will now decode messages via <code>orjson</code> resulting in an ~6% overall performance improvement.</li> <li>Built-in <code>asyncio</code> event loops are now patched via <code>nest_asyncio</code>, resulting in an ~10% overall performance improvement. This has no performance impact if you are running your webserver with <code>uvloop</code>.</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Fix bug where <code>REACTPY_WEBSOCKET_URL</code> always generates a warning if unset.</li> <li>Fixed bug on Windows where <code>assert f is self._write_fut</code> would be raised by <code>uvicorn</code> when <code>REACTPY_BACKHAUL_THREAD = True</code>.</li> <li>Fixed bug on Windows where rendering behavior would be jittery with <code>daphne</code> when <code>REACTPY_BACKHAUL_THREAD = True</code>.</li> </ul>"},{"location":"changelog/#331-2023-08-08","title":"3.3.1 - 2023-08-08","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Additional system checks for ReactPy misconfigurations.</li> </ul>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li><code>REACTPY_BACKHAUL_THREAD</code> now defaults to <code>False</code>.</li> </ul>"},{"location":"changelog/#330-2023-08-05","title":"3.3.0 - 2023-08-05","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Added system checks for a variety of common ReactPy misconfigurations.</li> <li><code>REACTPY_BACKHAUL_THREAD</code> setting to enable/disable threading behavior.</li> </ul>"},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>If using <code>settings.py:REACTPY_DATABASE</code>, <code>reactpy_django.database.Router</code> must now be registered in <code>settings.py:DATABASE_ROUTERS</code>.</li> <li>By default, ReactPy will now use a backhaul thread to increase performance.</li> <li>Minimum Python version required is now <code>3.9</code></li> <li>A thread-safe cache is no longer required.</li> </ul>"},{"location":"changelog/#321-2023-06-29","title":"3.2.1 - 2023-06-29","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>Template tag exception details are now rendered on the webpage when <code>settings.py:DEBUG</code> is enabled.</li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Prevent exceptions within the <code>component</code> template tag from causing the whole template to fail to render.</li> </ul>"},{"location":"changelog/#320-2023-06-08","title":"3.2.0 - 2023-06-08","text":""},{"location":"changelog/#added_6","title":"Added","text":"<ul> <li>Added warning if poor system/cache/database performance is detected while in <code>DEBUG</code> mode.</li> <li>Added <code>REACTPY_AUTH_BACKEND</code> setting to allow for custom authentication backends.</li> </ul>"},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>Using <code>SessionMiddlewareStack</code> is now optional.</li> <li>Using <code>AuthMiddlewareStack</code> is now optional.</li> </ul>"},{"location":"changelog/#310-2023-05-06","title":"3.1.0 - 2023-05-06","text":""},{"location":"changelog/#added_7","title":"Added","text":"<ul> <li><code>use_query</code> now supports async functions.</li> <li><code>use_mutation</code> now supports async functions.</li> <li><code>reactpy_django.types.QueryOptions.thread_sensitive</code> option to customize how sync queries are executed.</li> <li><code>reactpy_django.hooks.use_mutation</code> now accepts <code>reactpy_django.types.MutationOptions</code> option to customize how mutations are executed.</li> </ul>"},{"location":"changelog/#changed_5","title":"Changed","text":"<ul> <li>The <code>mutate</code> argument on <code>reactpy_django.hooks.use_mutation</code> has been renamed to <code>mutation</code>.</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Fix bug where ReactPy utilizes Django's default cache timeout, which can prematurely expire the component cache.</li> </ul>"},{"location":"changelog/#301-2023-04-06","title":"3.0.1 - 2023-04-06","text":""},{"location":"changelog/#changed_6","title":"Changed","text":"<ul> <li><code>django-reactpy</code> database entries are no longer cleaned during Django application startup. Instead, it will occur on webpage loads if <code>REACTPY_RECONNECT_MAX</code> seconds has elapsed since the last cleaning.</li> </ul>"},{"location":"changelog/#300-reactpy-2023-03-30","title":"3.0.0-reactpy - 2023-03-30","text":""},{"location":"changelog/#changed_7","title":"Changed","text":"<ul> <li><code>django-idom</code> has been renamed to <code>reactpy-django</code>! Please note that all references to the word <code>idom</code> in your code should be changed to <code>reactpy</code>. See the docs for more details.</li> </ul>"},{"location":"changelog/#300-2023-03-08","title":"3.0.0 - 2023-03-08","text":"Note <p>This is Django-IDOM's biggest update yet!</p> <p>To upgrade from previous version you will need to...</p> <ol> <li>Install <code>django-idom &gt;= 3.0.0</code></li> <li>Run <code>idom rewrite-keys &lt;DIR&gt;</code> and <code>idom rewrite-camel-case-props &lt;DIR&gt;</code> to update your <code>idom.html.*</code> calls to the new syntax</li> <li>Run <code>python manage.py migrate</code> to create the new Django-IDOM database entries</li> </ol>"},{"location":"changelog/#added_8","title":"Added","text":"<ul> <li>The <code>idom</code> client will automatically configure itself to debug mode depending on <code>settings.py:DEBUG</code>.</li> <li><code>use_connection</code> hook for returning the browser's active <code>Connection</code>.</li> <li><code>IDOM_CACHE</code> is now configurable within <code>settings.py</code> to whatever cache name you wish.</li> </ul>"},{"location":"changelog/#changed_8","title":"Changed","text":"<ul> <li>It is now mandatory to run <code>manage.py migrate</code> after installing IDOM.</li> <li>Bumped the minimum IDOM version to 1.0.0. Due to IDOM 1.0.0, <code>idom.html.*</code>...<ul> <li>HTML properties can now be <code>snake_case</code>. For example <code>className</code> now becomes <code>class_name</code>.</li> <li><code>key=...</code> is now declared within the props <code>dict</code> (rather than as a <code>kwarg</code>).</li> </ul> </li> <li>The <code>component</code> template tag now supports both positional and keyword arguments.</li> <li>The <code>component</code> template tag now supports non-serializable arguments.</li> <li><code>IDOM_WS_MAX_RECONNECT_TIMEOUT</code> setting has been renamed to <code>IDOM_RECONNECT_MAX</code>.</li> </ul>"},{"location":"changelog/#removed_2","title":"Removed","text":"<ul> <li><code>django_idom.hooks.use_websocket</code> has been removed. The similar replacement is <code>django_idom.hooks.use_connection</code>.</li> <li><code>django_idom.types.IdomWebsocket</code> has been removed. The similar replacement is <code>django_idom.types.Connection</code>.</li> <li><code>settings.py:CACHE['idom']</code> is no longer used by default. The name of the cache back-end must now be specified with the <code>IDOM_CACHE</code> setting.</li> </ul>"},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li><code>view_to_component</code> will now retain the contents of a <code>&lt;head&gt;</code> tag when rendering.</li> <li>React client is now set to <code>production</code> rather than <code>development</code>.</li> <li><code>use_query</code> will now utilize <code>field.related_name</code> when postprocessing many-to-one relationships.</li> </ul>"},{"location":"changelog/#security","title":"Security","text":"<ul> <li>Fixed a potential method of component template tag argument spoofing.</li> <li>Exception information will no longer be displayed on the page, based on the value of <code>settings.py:DEBUG</code>.</li> </ul>"},{"location":"changelog/#221-2023-01-09","title":"2.2.1 - 2023-01-09","text":""},{"location":"changelog/#fixed_4","title":"Fixed","text":"<ul> <li>Fixed bug where <code>use_query</code> would not recursively fetch many-to-one relationships.</li> <li>IDOM preloader will now print out the exception stack when failing to import a module.</li> </ul>"},{"location":"changelog/#220-2022-12-28","title":"2.2.0 - 2022-12-28","text":""},{"location":"changelog/#added_9","title":"Added","text":"<ul> <li>Add <code>options: QueryOptions</code> parameter to <code>use_query</code> to allow for configuration of this hook.</li> </ul>"},{"location":"changelog/#changed_9","title":"Changed","text":"<ul> <li>By default, <code>use_query</code> will recursively prefetch all many-to-many or many-to-one relationships to prevent <code>SynchronousOnlyOperation</code> exceptions.</li> </ul>"},{"location":"changelog/#removed_3","title":"Removed","text":"<ul> <li><code>django_idom.hooks._fetch_lazy_fields</code> has been deleted. The equivalent replacement is <code>django_idom.utils.django_query_postprocessor</code>.</li> </ul>"},{"location":"changelog/#210-2022-11-01","title":"2.1.0 - 2022-11-01","text":""},{"location":"changelog/#changed_10","title":"Changed","text":"<ul> <li>Minimum <code>channels</code> version is now <code>4.0.0</code>.</li> </ul>"},{"location":"changelog/#fixed_5","title":"Fixed","text":"<ul> <li>Change type hint on <code>view_to_component</code> callable to have <code>request</code> argument be optional.</li> <li>Change type hint on <code>view_to_component</code> to represent it as a decorator with parenthesis (such as <code>@view_to_component(compatibility=True)</code>)</li> </ul>"},{"location":"changelog/#security_1","title":"Security","text":"<ul> <li>Add note to docs about potential information exposure via <code>view_to_component</code> when using <code>compatibility=True</code>.</li> </ul>"},{"location":"changelog/#201-2022-10-18","title":"2.0.1 - 2022-10-18","text":""},{"location":"changelog/#fixed_6","title":"Fixed","text":"<ul> <li>Ability to use <code>key=...</code> parameter on all prefabricated components.</li> </ul>"},{"location":"changelog/#200-2022-10-17","title":"2.0.0 - 2022-10-17","text":""},{"location":"changelog/#added_10","title":"Added","text":"<ul> <li><code>use_origin</code> hook for returning the browser's <code>location.origin</code>.</li> </ul>"},{"location":"changelog/#changed_11","title":"Changed","text":"<ul> <li><code>view_to_component</code> now returns a <code>Callable</code>, instead of directly returning a <code>Component</code>. Check the docs for new usage info.</li> <li><code>use_mutation</code> and <code>use_query</code> will now log any query failures.</li> </ul>"},{"location":"changelog/#fixed_7","title":"Fixed","text":"<ul> <li>Allow <code>use_mutation</code> to have <code>refetch=None</code>, as the docs suggest is possible.</li> <li><code>use_query</code> will now prefetch all fields to prevent <code>SynchronousOnlyOperation</code> exceptions.</li> <li><code>view_to_component</code>, <code>django_css</code>, and <code>django_js</code> type hints will now display like normal functions.</li> <li>IDOM preloader no longer attempts to parse commented out IDOM components.</li> <li>Tests are now fully functional on Windows</li> </ul>"},{"location":"changelog/#120-2022-09-19","title":"1.2.0 - 2022-09-19","text":""},{"location":"changelog/#added_11","title":"Added","text":"<ul> <li><code>auth_required</code> decorator to prevent your components from rendering to unauthenticated users.</li> <li><code>use_query</code> hook for fetching database values.</li> <li><code>use_mutation</code> hook for modifying database values.</li> <li><code>view_to_component</code> utility to convert legacy Django views to IDOM components.</li> </ul>"},{"location":"changelog/#changed_12","title":"Changed","text":"<ul> <li>Bumped the minimum IDOM version to 0.40.2</li> <li>Testing suite now uses <code>playwright</code> instead of <code>selenium</code></li> </ul>"},{"location":"changelog/#fixed_8","title":"Fixed","text":"<ul> <li>IDOM preloader is no longer sensitive to whitespace within template tags.</li> </ul>"},{"location":"changelog/#110-2022-07-01","title":"1.1.0 - 2022-07-01","text":""},{"location":"changelog/#added_12","title":"Added","text":"<ul> <li><code>django_css</code> and <code>django_js</code> components to defer loading CSS &amp; JS files until needed.</li> </ul>"},{"location":"changelog/#changed_13","title":"Changed","text":"<ul> <li>Bumped the minimum IDOM version to 0.39.0</li> </ul>"},{"location":"changelog/#100-2022-05-22","title":"1.0.0 - 2022-05-22","text":""},{"location":"changelog/#added_13","title":"Added","text":"<ul> <li>Django specific hooks! <code>use_websocket</code>, <code>use_scope</code>, and <code>use_location</code> are now available within the <code>django_idom.hooks</code> module.</li> <li>Documentation has been placed into a formal docs webpage.</li> <li>Logging for when a component fails to import, or if no components were found within Django.</li> </ul>"},{"location":"changelog/#changed_14","title":"Changed","text":"<ul> <li><code>idom_component</code> template tag has been renamed to <code>component</code></li> <li>Bumped the minimum IDOM version to 0.38.0</li> </ul>"},{"location":"changelog/#removed_4","title":"Removed","text":"<ul> <li><code>websocket</code> parameter for components has been removed. Functionally, it is replaced with <code>django_idom.hooks.use_websocket</code>.</li> </ul>"},{"location":"changelog/#005-2022-04-04","title":"0.0.5 - 2022-04-04","text":""},{"location":"changelog/#changed_15","title":"Changed","text":"<ul> <li>Bumped the minimum IDOM version to 0.37.2</li> </ul>"},{"location":"changelog/#fixed_9","title":"Fixed","text":"<ul> <li>ModuleNotFoundError: No module named <code>idom.core.proto</code> caused by IDOM 0.37.2</li> </ul>"},{"location":"changelog/#004-2022-03-05","title":"0.0.4 - 2022-03-05","text":""},{"location":"changelog/#changed_16","title":"Changed","text":"<ul> <li>Bumped the minimum IDOM version to 0.37.1</li> </ul>"},{"location":"changelog/#003-2022-02-19","title":"0.0.3 - 2022-02-19","text":""},{"location":"changelog/#changed_17","title":"Changed","text":"<ul> <li>Bumped the minimum IDOM version to 0.36.3</li> </ul>"},{"location":"changelog/#002-2022-01-30","title":"0.0.2 - 2022-01-30","text":""},{"location":"changelog/#added_14","title":"Added","text":"<ul> <li>Ability to declare the HTML class of the top-level component <code>div</code></li> <li><code>name = ...</code> parameter to IDOM HTTP paths for use with <code>django.urls.reverse()</code></li> <li>Cache versioning to automatically invalidate old web module files from the cache back-end</li> <li>Automatic pre-population of the IDOM component registry</li> <li>Type hinting for <code>IdomWebsocket</code></li> </ul>"},{"location":"changelog/#changed_18","title":"Changed","text":"<ul> <li>Fetching web modules from disk and/or cache is now fully async</li> <li>Static files are now contained within a <code>django_idom/</code> parent folder</li> <li>Upgraded IDOM to version <code>0.36.0</code></li> <li>Minimum Django version required is now <code>4.0</code></li> <li>Minimum Python version required is now <code>3.8</code></li> </ul>"},{"location":"changelog/#removed_5","title":"Removed","text":"<ul> <li><code>IDOM_WEB_MODULES_PATH</code> has been replaced with Django <code>include(...)</code></li> <li><code>IDOM_WS_MAX_RECONNECT_DELAY</code> has been renamed to <code>IDOM_WS_MAX_RECONNECT_TIMEOUT</code></li> <li><code>idom_web_modules</code> cache back-end has been renamed to <code>idom</code></li> </ul>"},{"location":"changelog/#fixed_10","title":"Fixed","text":"<ul> <li>Increase test timeout values to prevent false positives</li> <li>Windows compatibility for building Django-IDOM</li> </ul>"},{"location":"changelog/#security_2","title":"Security","text":"<ul> <li>Fixed potential directory traversal attack on the IDOM web modules URL</li> </ul>"},{"location":"changelog/#001-2021-08-18","title":"0.0.1 - 2021-08-18","text":""},{"location":"changelog/#added_15","title":"Added","text":"<ul> <li>Support for IDOM within the Django</li> </ul>"},{"location":"contribute/code/","title":"Code","text":""},{"location":"contribute/code/#overview","title":"Overview","text":"<p>      You will need to set up a Python environment to develop ReactPy-Django.  </p> <p>Note</p> <p>Looking to contribute features that are not Django specific?</p> <p>Everything within the <code>reactpy-django</code> repository must be specific to Django integration. Check out the ReactPy Core documentation to contribute general features such as components, hooks, and events.</p>"},{"location":"contribute/code/#modifying-code","title":"Modifying Code","text":"<p>If you plan to make code changes to this repository, you will need to install the following dependencies first:</p> <ul> <li>Python 3.9+</li> <li>Git</li> <li>NPM for installing and managing Javascript</li> </ul> <p>Once done, you should clone this repository:</p> <pre><code>git clone https://github.com/reactive-python/reactpy-django.git\ncd reactpy-django\n</code></pre> <p>Then, by running the command below you can:</p> <ul> <li>Install an editable version of the Python code</li> <li>Download, build, and install Javascript dependencies</li> </ul> <pre><code>pip install -e . -r requirements.txt\n</code></pre> <p>Finally, to verify that everything is working properly, you can manually run the test webserver.</p> <pre><code>cd tests\npython manage.py runserver\n</code></pre> <p>Navigate to <code>http://127.0.0.1:8000</code> to see if the tests are rendering correctly.</p>"},{"location":"contribute/code/#github-pull-request","title":"GitHub Pull Request","text":"<p>Now, you can create/modify the ReactPy-Django source code, and Pull Request (PR) your changes to our GitHub repository.</p> <p>To learn how to create GitHub PRs, click here.</p>"},{"location":"contribute/docs/","title":"Docs","text":""},{"location":"contribute/docs/#overview","title":"Overview","text":"<p>  You will need to set up a Python environment to create, test, and preview docs changes.  </p>"},{"location":"contribute/docs/#modifying-docs","title":"Modifying Docs","text":"<p>If you plan to make changes to this documentation, you will need to install the following dependencies first:</p> <ul> <li>Python 3.9+</li> <li>Git</li> </ul> <p>Once done, you should clone this repository:</p> <pre><code>git clone https://github.com/reactive-python/reactpy-django.git\ncd reactpy-django\n</code></pre> <p>Then, by running the command below you can:</p> <ul> <li>Install an editable version of the documentation</li> <li>Self-host a test server for the documentation</li> </ul> <pre><code>pip install -e . -r requirements.txt --upgrade\n</code></pre> <p>Finally, to verify that everything is working properly, you can manually run the docs preview webserver.</p> <pre><code>mkdocs serve\n</code></pre> <p>Navigate to <code>http://127.0.0.1:8000</code> to view a preview of the documentation.</p>"},{"location":"contribute/docs/#github-pull-request","title":"GitHub Pull Request","text":"<p>Now, you can create/modify the ReactPy-Django source code, and Pull Request (PR) your changes to our GitHub repository.</p> <p>To learn how to create GitHub PRs, click here.</p>"},{"location":"contribute/running-tests/","title":"Running Tests","text":""},{"location":"contribute/running-tests/#overview","title":"Overview","text":"<p>  You will need to set up a Python environment to run the ReactPy-Django test suite.  </p>"},{"location":"contribute/running-tests/#running-tests","title":"Running Tests","text":"<p>This repository uses Nox to run tests. For a full test of available scripts run <code>nox -l</code>.</p> <p>If you plan to run tests, you will need to install the following dependencies first:</p> <ul> <li>Python 3.9+</li> <li>Git</li> </ul> <p>Once done, you should clone this repository:</p> <pre><code>git clone https://github.com/reactive-python/reactpy-django.git\ncd reactpy-django\npip install -e . -r requirements.txt --upgrade\n</code></pre>"},{"location":"contribute/running-tests/#full-test-suite","title":"Full Test Suite","text":"<p>By running the command below you can run the full test suite:</p> <pre><code>nox -s test\n</code></pre> <p>Or, if you want to run the tests in the background:</p> <pre><code>nox -s test -- --headless\n</code></pre>"},{"location":"contribute/running-tests/#django-tests","title":"Django Tests","text":"<p>If you want to only run our Django tests in your current environment, you can use the following command:</p> <pre><code>cd tests\npython manage.py test\n</code></pre>"},{"location":"contribute/running-tests/#django-test-webserver","title":"Django Test Webserver","text":"<p>If you want to manually run the Django test application, you can use the following command:</p> <pre><code>cd tests\npython manage.py runserver\n</code></pre>"},{"location":"features/components/","title":"Components","text":""},{"location":"features/components/#overview","title":"Overview","text":"<p>  We supply some pre-designed that components can be used to help simplify development.  </p>"},{"location":"features/components/#view-to-component","title":"View To Component","text":"<p>Convert any Django view into a ReactPy component by using this decorator. Compatible with Function Based Views and Class Based Views. Views can be sync or async.</p> components.py <pre><code>from django.http import HttpResponse\nfrom reactpy import component, html\nfrom reactpy_django.components import view_to_component\n\n\n@view_to_component\ndef hello_world_view(request):\n    return HttpResponse(\"Hello World!\")\n\n\n@component\ndef my_component():\n    return html.div(\n        hello_world_view(),\n    )\n</code></pre> See Interface <p>Parameters</p> Name Type Description Default <code>view</code> <code>Callable | View</code> The view function or class to convert. N/A <code>compatibility</code> <code>bool</code> If True, the component will be rendered in an iframe. When using compatibility mode <code>tranforms</code>, <code>strict_parsing</code>, <code>request</code>, <code>args</code>, and <code>kwargs</code> arguments will be ignored. <code>False</code> <code>transforms</code> <code>Sequence[Callable[[VdomDict], Any]]</code> A list of functions that transforms the newly generated VDOM. The functions will be called on each VDOM node. <code>tuple</code> <code>strict_parsing</code> <code>bool</code> If True, an exception will be generated if the HTML does not perfectly adhere to HTML5. <code>True</code> <p>Returns</p> Type Description <code>_ViewComponentConstructor</code> A function that takes <code>request, *args, key, **kwargs</code> and returns a ReactPy component. All parameters are directly provided to your view, besides <code>key</code> which is used by ReactPy. Potential information exposure when using <code>compatibility = True</code> <p>When using <code>compatibility</code> mode, ReactPy automatically exposes a URL to your view.</p> <p>It is your responsibility to ensure privileged information is not leaked via this method.</p> <p>You must implement a method to ensure only authorized users can access your view. This can be done via directly writing conditionals into your view, or by adding decorators such as <code>user_passes_test</code> to your views. For example...</p> Function Based ViewClass Based View <pre><code>from django.contrib.auth.decorators import user_passes_test\nfrom reactpy_django.components import view_to_component\n\n\n@view_to_component(compatibility=True)\n@user_passes_test(lambda u: u.is_superuser)  # type: ignore[union-attr]\ndef example_view(request):\n    ...\n</code></pre> <pre><code>from django.contrib.auth.decorators import user_passes_test\nfrom django.utils.decorators import method_decorator\nfrom django.views.generic import TemplateView\nfrom reactpy_django.components import view_to_component\n\n\n@view_to_component(compatibility=True)\n@method_decorator(user_passes_test(lambda u: u.is_superuser), name=\"dispatch\")  # type: ignore[union-attr]\nclass ExampleView(TemplateView):\n    ...\n</code></pre> Existing limitations <p>There are currently several limitations of using <code>view_to_component</code> that may be resolved in a future version of <code>reactpy_django</code>.</p> <ul> <li>Requires manual intervention to change request methods beyond <code>GET</code>.</li> <li>ReactPy events cannot conveniently be attached to converted view HTML.</li> <li>Has no option to automatically intercept local anchor link (such as <code>&lt;a href='example/'&gt;&lt;/a&gt;</code>) click events.</li> </ul> <p>Please note these limitations do not exist when using <code>compatibility</code> mode.</p> How do I use this for Class Based Views? <p>You can simply pass your Class Based View directly into <code>view_to_component</code>.</p> components.py <pre><code>from django.http import HttpResponse\nfrom django.views import View\nfrom reactpy import component, html\nfrom reactpy_django.components import view_to_component\n\n\nclass HelloWorldView(View):\n    def get(self, request):\n        return HttpResponse(\"Hello World!\")\n\n\nvtc = view_to_component(HelloWorldView)\n\n\n@component\ndef my_component():\n    return html.div(\n        vtc(),\n    )\n</code></pre> How do I transform views from external libraries? <p>In order to convert external views, you can utilize <code>view_to_component</code> as a function, rather than a decorator.</p> components.py <pre><code>from example.views import example_view\nfrom reactpy import component, html\nfrom reactpy_django.components import view_to_component\n\nexample_vtc = view_to_component(example_view)\n\n\n@component\ndef my_component():\n    return html.div(\n        example_vtc(),\n    )\n</code></pre> How do I provide <code>request</code>, <code>args</code>, and <code>kwargs</code> to a view? <p><code>Request</code></p> <p>You can use the <code>request</code> parameter to provide the view a custom request object.</p> components.py <pre><code>from django.http import HttpRequest, HttpResponse\nfrom reactpy import component, html\nfrom reactpy_django.components import view_to_component\n\nexample_request = HttpRequest()\nexample_request.method = \"PUT\"\n\n\n@view_to_component\ndef hello_world_view(request):\n    return HttpResponse(f\"Hello World! {request.method}\")\n\n\n@component\ndef my_component():\n    return html.div(\n        hello_world_view(\n            example_request,\n        ),\n    )\n</code></pre> <p><code>args</code> and <code>kwargs</code></p> <p>You can use the <code>args</code> and <code>kwargs</code> parameters to provide positional and keyworded arguments to a view.</p> components.py <pre><code>from django.http import HttpResponse\nfrom reactpy import component, html\nfrom reactpy_django.components import view_to_component\n\n\n@view_to_component\ndef hello_world_view(request, arg1, arg2, key1=None, key2=None):\n    return HttpResponse(f\"Hello World! {arg1} {arg2} {key1} {key2}\")\n\n\n@component\ndef my_component():\n    return html.div(\n        hello_world_view(\n            None,  # Your request object (optional)\n            \"value_1\",\n            \"value_2\",\n            key1=\"abc\",\n            key2=\"123\",\n        ),\n    )\n</code></pre> How do I use <code>strict_parsing</code>, <code>compatibility</code>, and <code>transforms</code>? <p><code>strict_parsing</code></p> <p>By default, an exception will be generated if your view's HTML does not perfectly adhere to HTML5.</p> <p>However, there are some circumstances where you may not have control over the original HTML, so you may be unable to fix it. Or you may be relying on non-standard HTML tags such as <code>&lt;my-tag&gt; Hello World &lt;/my-tag&gt;</code>.</p> <p>In these scenarios, you may want to rely on best-fit parsing by setting the <code>strict_parsing</code> parameter to <code>False</code>.</p> components.py <pre><code>from django.http import HttpResponse\nfrom reactpy import component, html\nfrom reactpy_django.components import view_to_component\n\n\n@view_to_component(strict_parsing=False)\ndef hello_world_view(request):\n    return HttpResponse(\"&lt;my-tag&gt; Hello World &lt;/my-tag&gt;\")\n\n\n@component\ndef my_component():\n    return html.div(\n        hello_world_view(),\n    )\n</code></pre> <p>Note: Best-fit parsing is designed to be similar to how web browsers would handle non-standard or broken HTML.</p> <p><code>compatibility</code></p> <p>For views that rely on HTTP responses other than <code>GET</code> (such as <code>PUT</code>, <code>POST</code>, <code>PATCH</code>, etc), you should consider using compatibility mode to render your view within an iframe.</p> <p>Any view can be rendered within compatibility mode. However, the <code>transforms</code>, <code>strict_parsing</code>, <code>request</code>, <code>args</code>, and <code>kwargs</code> arguments do not apply to compatibility mode.</p> components.py <pre><code>from django.http import HttpResponse\nfrom reactpy import component, html\nfrom reactpy_django.components import view_to_component\n\n\n@view_to_component(compatibility=True)\ndef hello_world_view(request):\n    return HttpResponse(\"Hello World!\")\n\n\n@component\ndef my_component():\n    return html.div(\n        hello_world_view(),\n    )\n</code></pre> <p>Note: By default the <code>compatibility</code> iframe is unstyled, and thus won't look pretty until you add some CSS.</p> <p><code>transforms</code></p> <p>After your view has been turned into VDOM (python dictionaries), <code>view_to_component</code> will call your <code>transforms</code> functions on every VDOM node.</p> <p>This allows you to modify your view prior to rendering.</p> <p>For example, if you are trying to modify the text of a node with a certain <code>id</code>, you can create a transform like such:</p> components.py <pre><code>from django.http import HttpResponse\nfrom reactpy import component, html\nfrom reactpy_django.components import view_to_component\n\n\ndef example_transform(vdom):\n    attributes = vdom.get(\"attributes\")\n    if attributes and attributes.get(\"id\") == \"hello-world\":\n        vdom[\"children\"][0] = \"Good Bye World!\"\n\n\n@view_to_component(transforms=[example_transform])\ndef hello_world_view(request):\n    return HttpResponse(\"&lt;div id='hello-world'&gt; Hello World! &lt;div&gt;\")\n\n\n@component\ndef my_component():\n    return html.div(\n        hello_world_view(),\n    )\n</code></pre>"},{"location":"features/components/#django-css","title":"Django CSS","text":"<p>Allows you to defer loading a CSS stylesheet until a component begins rendering. This stylesheet must be stored within Django's static files.</p> components.py <pre><code>from reactpy import component, html\nfrom reactpy_django.components import django_css\n\n\n@component\ndef my_component():\n    return html.div(\n        django_css(\"css/buttons.css\"),\n        html.button(\"My Button!\"),\n    )\n</code></pre> See Interface <p>Parameters</p> Name Type Description Default <code>static_path</code> <code>str</code> The path to the static file. This path is identical to what you would use on a <code>static</code> template tag. N/A <code>key</code> <code>Key | None</code> A key to uniquely identify this component which is unique amongst a component's immediate siblings <code>None</code> <p>Returns</p> Type Description <code>Component</code> A ReactPy component. Should I put <code>django_css</code> at the top of my HTML? <p>Yes, if the stylesheet contains styling for your component.</p> Can I load static CSS using <code>html.link</code> instead? <p>While you can load stylesheets with <code>html.link</code>, keep in mind that loading this way does not ensure load order. Thus, your stylesheet will be loaded after your component is displayed. This would likely cause unintended visual behavior, so use this at your own discretion.</p> <p>Here's an example on what you should avoid doing for Django static files:</p> <pre><code>from django.templatetags.static import static\nfrom reactpy import component, html\n\n\n@component\ndef my_component():\n    return html.div(\n        html.link({\"rel\": \"stylesheet\", \"href\": static(\"css/buttons.css\")}),\n        html.button(\"My Button!\"),\n    )\n</code></pre> How do I load external CSS? <p><code>django_css</code> can only be used with local static files.</p> <p>For external CSS, substitute <code>django_css</code> with <code>html.link</code>.</p> <pre><code>from reactpy import component, html\n\n\n@component\ndef my_component():\n    return html.div(\n        html.link(\n            {\"rel\": \"stylesheet\", \"href\": \"https://example.com/external-styles.css\"}\n        ),\n        html.button(\"My Button!\"),\n    )\n</code></pre> Why not load my CSS in <code>&lt;head&gt;</code>? <p>Traditionally, stylesheets are loaded in your <code>&lt;head&gt;</code> using the <code>{% load static %}</code> template tag.</p> <p>To help improve webpage load times, you can use the <code>django_css</code> component to defer loading your stylesheet until it is needed.</p>"},{"location":"features/components/#django-js","title":"Django JS","text":"<p>Allows you to defer loading JavaScript until a component begins rendering. This JavaScript must be stored within Django's static files.</p> components.py <pre><code>from reactpy import component, html\nfrom reactpy_django.components import django_js\n\n\n@component\ndef my_component():\n    return html.div(\n        html.button(\"My Button!\"),\n        django_js(\"js/scripts.js\"),\n    )\n</code></pre> See Interface <p>Parameters</p> Name Type Description Default <code>static_path</code> <code>str</code> The path to the static file. This path is identical to what you would use on a <code>static</code> template tag. N/A <code>key</code> <code>Key | None</code> A key to uniquely identify this component which is unique amongst a component's immediate siblings <code>None</code> <p>Returns</p> Type Description <code>Component</code> A ReactPy component. Should I put <code>django_js</code> at the bottom of my HTML? <p>Yes, if your scripts are reliant on the contents of the component.</p> Can I load static JavaScript using <code>html.script</code> instead? <p>While you can load JavaScript with <code>html.script</code>, keep in mind that loading this way does not ensure load order. Thus, your JavaScript will likely be loaded at an arbitrary time after your component is displayed.</p> <p>Here's an example on what you should avoid doing for Django static files:</p> <pre><code>from django.templatetags.static import static\nfrom reactpy import component, html\n\n\n@component\ndef my_component():\n    return html.div(\n        html.script({\"src\": static(\"js/scripts.js\")}),\n        html.button(\"My Button!\"),\n    )\n</code></pre> How do I load external JS? <p><code>django_js</code> can only be used with local static files.</p> <p>For external JavaScript, substitute <code>django_js</code> with <code>html.script</code>.</p> <pre><code>from reactpy import component, html\n\n\n@component\ndef my_component():\n    return html.div(\n        html.script({\"src\": \"https://example.com/external-scripts.js\"}),\n        html.button(\"My Button!\"),\n    )\n</code></pre> Why not load my JS in <code>&lt;head&gt;</code>? <p>Traditionally, JavaScript is loaded in your <code>&lt;head&gt;</code> using the <code>{% load static %}</code> template tag.</p> <p>To help improve webpage load times, you can use the <code>django_js</code> component to defer loading your JavaScript until it is needed.</p>"},{"location":"features/decorators/","title":"Decorators","text":""},{"location":"features/decorators/#overview","title":"Overview","text":"<p>  Decorator functions can be used within your <code>components.py</code> to help simplify development.  </p>"},{"location":"features/decorators/#auth-required","title":"Auth Required","text":"<p>You can limit access to a component to users with a specific <code>auth_attribute</code> by using this decorator (with or without parentheses).</p> <p>By default, this decorator checks if the user is logged in and not deactivated (<code>is_active</code>).</p> <p>This decorator is commonly used to selectively render a component only if a user <code>is_staff</code> or <code>is_superuser</code>.</p> components.py <pre><code>from reactpy import component, html\nfrom reactpy_django.decorators import auth_required\n\n\n@component\n@auth_required\ndef my_component():\n    return html.div(\"I am logged in!\")\n</code></pre> See Interface <p>Parameters</p> Name Type Description Default <code>auth_attribute</code> <code>str</code> The value to check within the user object. This is checked in the form of <code>UserModel.&lt;auth_attribute&gt;</code>. <code>\"is_active\"</code> <code>fallback</code> <code>ComponentType</code>, <code>VdomDict</code>, <code>None</code> The <code>component</code> or <code>reactpy.html</code> snippet to render if the user is not authenticated. <code>None</code> <p>Returns</p> Type Description <code>Component</code> A ReactPy component. <code>VdomDict</code> An <code>reactpy.html</code> snippet. <code>None</code> No component render. How do I render a different component if authentication fails? <p>You can use a component with the <code>fallback</code> argument, as seen below.</p> components.py <pre><code>from reactpy import component, html\nfrom reactpy_django.decorators import auth_required\n\n\n@component\ndef my_component_fallback():\n    return html.div(\"I am NOT logged in!\")\n\n\n@component\n@auth_required(fallback=my_component_fallback)\ndef my_component():\n    return html.div(\"I am logged in!\")\n</code></pre> How do I render a simple <code>reactpy.html</code> snippet if authentication fails? <p>You can use a <code>reactpy.html</code> snippet with the <code>fallback</code> argument, as seen below.</p> components.py <pre><code>from reactpy import component, html\nfrom reactpy_django.decorators import auth_required\n\n\n@component\n@auth_required(fallback=html.div(\"I am NOT logged in!\"))\ndef my_component():\n    return html.div(\"I am logged in!\")\n</code></pre> How can I check if a user <code>is_staff</code>? <p>You can set the <code>auth_attribute</code> to <code>is_staff</code>, as seen blow.</p> components.py <pre><code>from reactpy import component, html\nfrom reactpy_django.decorators import auth_required\n\n\n@component\n@auth_required(auth_attribute=\"is_staff\")\ndef my_component():\n    return html.div(\"I am logged in!\")\n</code></pre> How can I check for a custom attribute? <p>You will need to be using a custom user model within your Django instance.</p> <p>For example, if your user model has the field <code>is_really_cool</code> ...</p> models.py <pre><code>from django.contrib.auth.models import AbstractBaseUser\n\n\nclass CustomUserModel(AbstractBaseUser):\n    @property\n    def is_really_cool(self):\n        return True\n</code></pre> <p>... then you would do the following within your decorator:</p> components.py <pre><code>from reactpy import component, html\nfrom reactpy_django.decorators import auth_required\n\n\n@component\n@auth_required(auth_attribute=\"is_really_cool\")\ndef my_component():\n    return html.div(\"I am logged in!\")\n</code></pre>"},{"location":"features/hooks/","title":"Hooks","text":""},{"location":"features/hooks/#overview","title":"Overview","text":"<p>  Prefabricated hooks can be used within your <code>components.py</code> to help simplify development.  </p> <p>Note</p> <p>Looking for standard React hooks?</p> <p>This package only contains Django specific hooks. Standard hooks can be found within <code>reactive-python/reactpy</code>.</p>"},{"location":"features/hooks/#use-query","title":"Use Query","text":"<p>The <code>use_query</code> hook is used fetch Django ORM queries.</p> <p>The function you provide into this hook must return either a <code>Model</code> or <code>QuerySet</code>.</p> components.pymodels.py <pre><code>from example.models import TodoItem\nfrom reactpy import component, html\nfrom reactpy_django.hooks import use_query\n\n\ndef get_items():\n    return TodoItem.objects.all()\n\n\n@component\ndef todo_list():\n    item_query = use_query(get_items)\n\n    if item_query.loading:\n        rendered_items = html.h2(\"Loading...\")\n    elif item_query.error or not item_query.data:\n        rendered_items = html.h2(\"Error when loading!\")\n    else:\n        rendered_items = html.ul([html.li(item, key=item) for item in item_query.data])\n\n    return html.div(\"Rendered items: \", rendered_items)\n</code></pre> <pre><code>from django.db.models import CharField, Model\n\n\nclass TodoItem(Model):\n    text: CharField = CharField(max_length=255)\n</code></pre> See Interface <p>Parameters</p> Name Type Description Default <code>options</code> <code>QueryOptions | None</code> An optional <code>QueryOptions</code> object that can modify how the query is executed. None <code>query</code> <code>Callable[_Params, _Result | None]</code> A callable that returns a Django <code>Model</code> or <code>QuerySet</code>. N/A <code>*args</code> <code>_Params.args</code> Positional arguments to pass into <code>query</code>. N/A <code>**kwargs</code> <code>_Params.kwargs</code> Keyword arguments to pass into <code>query</code>. N/A <p>Returns</p> Type Description <code>Query[_Result | None]</code> An object containing <code>loading</code>/<code>error</code> states, your <code>data</code> (if the query has successfully executed), and a <code>refetch</code> callable that can be used to re-run the query. How can I provide arguments to my query function? <p><code>*args</code> and <code>**kwargs</code> can be provided to your query function via <code>use_query</code> parameters.</p> components.py <pre><code>from reactpy import component\nfrom reactpy_django.hooks import use_query\n\n\ndef example_query(value: int, other_value: bool = False):\n    ...\n\n\n@component\ndef my_component():\n    query = use_query(\n        example_query,\n        123,\n        other_value=True,\n    )\n\n    return str(query.data)\n</code></pre> Why does <code>get_items</code> in the example return <code>TodoItem.objects.all()</code>? <p>This was a technical design decision to based on Apollo's <code>useQuery</code> hook, but ultimately helps avoid Django's <code>SynchronousOnlyOperation</code> exceptions.</p> <p>The <code>use_query</code> hook ensures the provided <code>Model</code> or <code>QuerySet</code> executes all deferred/lazy queries safely prior to reaching your components.</p> How can I use <code>QueryOptions</code> to customize fetching behavior? <p><code>thread_sensitive</code></p> <p>Whether to run your synchronous query function in thread-sensitive mode. Thread-sensitive mode is turned on by default due to Django ORM limitations. See Django's <code>sync_to_async</code> docs docs for more information.</p> <p>This setting only applies to sync query functions, and will be ignored for async functions.</p> components.py <pre><code>from reactpy import component\nfrom reactpy_django.hooks import use_query\nfrom reactpy_django.types import QueryOptions\n\n\ndef execute_thread_safe_operation():\n\"\"\"This is an example query function that does some thread-safe operation.\"\"\"\n    pass\n\n\n@component\ndef my_component():\n    query = use_query(\n        QueryOptions(thread_sensitive=False),\n        execute_thread_safe_operation,\n    )\n\n    if query.loading or query.error:\n        return None\n\n    return str(query.data)\n</code></pre> <p><code>postprocessor</code></p> <p>By default, automatic recursive fetching of <code>ManyToMany</code> or <code>ForeignKey</code> fields is enabled within the default <code>QueryOptions.postprocessor</code>. This is needed to prevent <code>SynchronousOnlyOperation</code> exceptions when accessing these fields within your ReactPy components.</p> <p>However, if you...</p> <ol> <li>Want to use this hook to defer IO intensive tasks to be computed in the background</li> <li>Want to to utilize <code>use_query</code> with a different ORM</li> </ol> <p>... then you can either set a custom <code>postprocessor</code>, or disable all postprocessing behavior by modifying the <code>QueryOptions.postprocessor</code> parameter. In the example below, we will set the <code>postprocessor</code> to <code>None</code> to disable postprocessing behavior.</p> components.py <pre><code>from reactpy import component\nfrom reactpy_django.hooks import use_query\nfrom reactpy_django.types import QueryOptions\n\n\ndef execute_io_intensive_operation():\n\"\"\"This is an example query function that does something IO intensive.\"\"\"\n    pass\n\n\n@component\ndef my_component():\n    query = use_query(\n        QueryOptions(postprocessor=None),\n        execute_io_intensive_operation,\n    )\n\n    if query.loading or query.error:\n        return None\n\n    return str(query.data)\n</code></pre> <p>If you wish to create a custom <code>postprocessor</code>, you will need to create a callable.</p> <p>The first argument of <code>postprocessor</code> must be the query <code>data</code>. All proceeding arguments are optional <code>postprocessor_kwargs</code> (see below). This <code>postprocessor</code> must return the modified <code>data</code>.</p> components.py <pre><code>from reactpy import component\nfrom reactpy_django.hooks import use_query\nfrom reactpy_django.types import QueryOptions\n\n\ndef my_postprocessor(data, example_kwarg=True):\n    if example_kwarg:\n        return data\n\n    return dict(data)\n\n\ndef execute_io_intensive_operation():\n\"\"\"This is an example query function that does something IO intensive.\"\"\"\n    pass\n\n\n@component\ndef my_component():\n    query = use_query(\n        QueryOptions(\n            postprocessor=my_postprocessor,\n            postprocessor_kwargs={\"example_kwarg\": False},\n        ),\n        execute_io_intensive_operation,\n    )\n\n    if query.loading or query.error:\n        return None\n\n    return str(query.data)\n</code></pre> <p><code>postprocessor_kwargs</code></p> <p>By default, automatic recursive fetching of <code>ManyToMany</code> or <code>ForeignKey</code> fields is enabled within the default <code>QueryOptions.postprocessor</code>. This is needed to prevent <code>SynchronousOnlyOperation</code> exceptions when accessing these fields within your ReactPy components.</p> <p>However, if you have deep nested trees of relational data, this may not be a desirable behavior. In these scenarios, you may prefer to manually fetch these relational fields using a second <code>use_query</code> hook.</p> <p>You can disable the prefetching behavior of the default <code>postprocessor</code> (located at <code>reactpy_django.utils.django_query_postprocessor</code>) via the <code>QueryOptions.postprocessor_kwargs</code> parameter.</p> components.py <pre><code>from example.models import TodoItem\nfrom reactpy import component\nfrom reactpy_django.hooks import use_query\nfrom reactpy_django.types import QueryOptions\n\n\ndef get_model_with_relationships():\n\"\"\"This is an example query function that gets `MyModel` which has a ManyToMany field, and\n    additionally other models that have formed a ForeignKey association to `MyModel`.\n\n    ManyToMany Field: `many_to_many_field`\n    ForeignKey Field: `foreign_key_field_set`\n    \"\"\"\n    return TodoItem.objects.get(id=1)\n\n\n@component\ndef my_component():\n    query = use_query(\n        QueryOptions(\n            postprocessor_kwargs={\"many_to_many\": False, \"many_to_one\": False}\n        ),\n        get_model_with_relationships,\n    )\n\n    if query.loading or query.error or not query.data:\n        return None\n\n    # By disabling `many_to_many` and `many_to_one`, accessing these fields will now\n    # generate a `SynchronousOnlyOperation` exception\n    return f\"{query.data.many_to_many_field} {query.data.foriegn_key_field_set}\"\n</code></pre> <p>Note: In Django's ORM design, the field name to access foreign keys is postfixed with <code>_set</code> by default.</p> Can I define async query functions? <p>Async functions are supported by <code>use_query</code>. You can use them in the same way as a sync query function.</p> <p>However, be mindful of Django async ORM restrictions.</p> components.py <pre><code>from channels.db import database_sync_to_async\nfrom example.models import TodoItem\nfrom reactpy import component, html\nfrom reactpy_django.hooks import use_query\n\n\nasync def get_items():\n    return await database_sync_to_async(TodoItem.objects.all)()\n\n\n@component\ndef todo_list():\n    item_query = use_query(get_items)\n\n    if item_query.loading:\n        rendered_items = html.h2(\"Loading...\")\n    elif item_query.error or not item_query.data:\n        rendered_items = html.h2(\"Error when loading!\")\n    else:\n        rendered_items = html.ul([html.li(item, key=item) for item in item_query.data])\n\n    return html.div(\"Rendered items: \", rendered_items)\n</code></pre> Can I make ORM calls without hooks? <p>Due to Django's ORM design, database queries must be deferred using hooks. Otherwise, you will see a <code>SynchronousOnlyOperation</code> exception.</p> <p>These <code>SynchronousOnlyOperation</code> exceptions may be resolved in a future version of Django containing an asynchronous ORM. However, it is best practice to always perform ORM calls in the background via hooks.</p>"},{"location":"features/hooks/#use-mutation","title":"Use Mutation","text":"<p>The <code>use_mutation</code> hook is used to create, update, or delete Django ORM objects.</p> <p>The function you provide into this hook will have no return value.</p> components.pymodels.py <pre><code>from example.models import TodoItem\nfrom reactpy import component, html\nfrom reactpy_django.hooks import use_mutation\n\n\ndef add_item(text: str):\n    TodoItem(text=text).save()\n\n\n@component\ndef todo_list():\n    item_mutation = use_mutation(add_item)\n\n    def submit_event(event):\n        if event[\"key\"] == \"Enter\":\n            item_mutation.execute(text=event[\"target\"][\"value\"])\n\n    if item_mutation.loading:\n        mutation_status = html.h2(\"Adding...\")\n    elif item_mutation.error:\n        mutation_status = html.h2(\"Error when adding!\")\n    else:\n        mutation_status = html.h2(\"Mutation done.\")\n\n    return html.div(\n        html.label(\"Add an item:\"),\n        html.input({\"type\": \"text\", \"onKeyDown\": submit_event}),\n        mutation_status,\n    )\n</code></pre> <pre><code>from django.db.models import CharField, Model\n\n\nclass TodoItem(Model):\n    text: CharField = CharField(max_length=255)\n</code></pre> See Interface <p>Parameters</p> Name Type Description Default <code>mutate</code> <code>Callable[_Params, bool | None]</code> A callable that performs Django ORM create, update, or delete functionality. If this function returns <code>False</code>, then your <code>refetch</code> function will not be used. N/A <code>refetch</code> <code>Callable[..., Any] | Sequence[Callable[..., Any]] | None</code> A <code>query</code> function (used by the <code>use_query</code> hook) or a sequence of <code>query</code> functions that will be called if the mutation succeeds. This is useful for refetching data after a mutation has been performed. <code>None</code> <p>Returns</p> Type Description <code>Mutation[_Params]</code> An object containing <code>loading</code>/<code>error</code> states, a <code>reset</code> callable that will set <code>loading</code>/<code>error</code> states to defaults, and a <code>execute</code> callable that will run the query. How can I provide arguments to my mutation function? <p><code>*args</code> and <code>**kwargs</code> can be provided to your mutation function via <code>mutation.execute</code> parameters.</p> components.py <pre><code>from reactpy import component\nfrom reactpy_django.hooks import use_mutation\n\n\ndef example_mutation(value: int, other_value: bool = False):\n    ...\n\n\n@component\ndef my_component():\n    mutation = use_mutation(example_mutation)\n\n    mutation.execute(123, other_value=True)\n\n    ...\n</code></pre> Can <code>use_mutation</code> trigger a refetch of <code>use_query</code>? <p>Yes, <code>use_mutation</code> can queue a refetch of a <code>use_query</code> via the <code>refetch=...</code> argument.</p> <p>The example below is a merge of the <code>use_query</code> and <code>use_mutation</code> examples above with the addition of a <code>refetch</code> argument on <code>use_mutation</code>.</p> <p>Please note that any <code>use_query</code> hooks that use <code>get_items</code> will be refetched upon a successful mutation.</p> components.pymodels.py <pre><code>from example.models import TodoItem\nfrom reactpy import component, html\nfrom reactpy_django.hooks import use_mutation, use_query\n\n\ndef get_items():\n    return TodoItem.objects.all()\n\n\ndef add_item(text: str):\n    TodoItem(text=text).save()\n\n\n@component\ndef todo_list():\n    item_query = use_query(get_items)\n    item_mutation = use_mutation(add_item, refetch=get_items)\n\n    def submit_event(event):\n        if event[\"key\"] == \"Enter\":\n            item_mutation.execute(text=event[\"target\"][\"value\"])\n\n    # Handle all possible query states\n    if item_query.loading:\n        rendered_items = html.h2(\"Loading...\")\n    elif item_query.error or not item_query.data:\n        rendered_items = html.h2(\"Error when loading!\")\n    else:\n        rendered_items = html.ul(html.li(item, key=item) for item in item_query.data)\n\n    # Handle all possible mutation states\n    if item_mutation.loading:\n        mutation_status = html.h2(\"Adding...\")\n    elif item_mutation.error:\n        mutation_status = html.h2(\"Error when adding!\")\n    else:\n        mutation_status = html.h2(\"Mutation done.\")\n\n    return html.div(\n        html.label(\"Add an item:\"),\n        html.input({\"type\": \"text\", \"onKeyDown\": submit_event}),\n        mutation_status,\n        rendered_items,\n    )\n</code></pre> <pre><code>from django.db.models import CharField, Model\n\n\nclass TodoItem(Model):\n    text: CharField = CharField(max_length=255)\n</code></pre> Can I make a failed <code>use_mutation</code> try again? <p>Yes, a <code>use_mutation</code> can be re-performed by calling <code>reset()</code> on your <code>use_mutation</code> instance.</p> <p>For example, take a look at <code>reset_event</code> below.</p> components.pymodels.py <pre><code>from example.models import TodoItem\nfrom reactpy import component, html\nfrom reactpy_django.hooks import use_mutation\n\n\ndef add_item(text: str):\n    TodoItem(text=text).save()\n\n\n@component\ndef todo_list():\n    item_mutation = use_mutation(add_item)\n\n    def reset_event(event):\n        item_mutation.reset()\n\n    def submit_event(event):\n        if event[\"key\"] == \"Enter\":\n            item_mutation.execute(text=event[\"target\"][\"value\"])\n\n    if item_mutation.loading:\n        mutation_status = html.h2(\"Adding...\")\n    elif item_mutation.error:\n        mutation_status = html.button({\"onClick\": reset_event}, \"Error: Try again!\")\n    else:\n        mutation_status = html.h2(\"Mutation done.\")\n\n    return html.div(\n        html.label(\"Add an item:\"),\n        html.input({\"type\": \"text\", \"onKeyDown\": submit_event}),\n        mutation_status,\n    )\n</code></pre> <pre><code>from django.db.models import CharField, Model\n\n\nclass TodoItem(Model):\n    text: CharField = CharField(max_length=255)\n</code></pre> Can I make ORM calls without hooks? <p>Due to Django's ORM design, database queries must be deferred using hooks. Otherwise, you will see a <code>SynchronousOnlyOperation</code> exception.</p> <p>These <code>SynchronousOnlyOperation</code> exceptions may be resolved in a future version of Django containing an asynchronous ORM. However, it is best practice to always perform ORM calls in the background via hooks.</p>"},{"location":"features/hooks/#use-connection","title":"Use Connection","text":"<p>You can fetch the Django Channels websocket at any time by using <code>use_connection</code>.</p> components.py <pre><code>from reactpy import component, html\nfrom reactpy_django.hooks import use_connection\n\n\n@component\ndef my_component():\n    my_connection = use_connection()\n    return html.div(str(my_connection))\n</code></pre> See Interface <p>Parameters</p> <p><code>None</code></p> <p>Returns</p> Type Description <code>Connection</code> The component's websocket."},{"location":"features/hooks/#use-scope","title":"Use Scope","text":"<p>This is a shortcut that returns the Websocket's <code>scope</code>.</p> components.py <pre><code>from reactpy import component, html\nfrom reactpy_django.hooks import use_scope\n\n\n@component\ndef my_component():\n    my_scope = use_scope()\n    return html.div(str(my_scope))\n</code></pre> See Interface <p>Parameters</p> <p><code>None</code></p> <p>Returns</p> Type Description <code>MutableMapping[str, Any]</code> The websocket's <code>scope</code>."},{"location":"features/hooks/#use-location","title":"Use Location","text":"<p>This is a shortcut that returns the Websocket's <code>path</code>.</p> <p>You can expect this hook to provide strings such as <code>/reactpy/my_path</code>.</p> components.py <pre><code>from reactpy import component, html\nfrom reactpy_django.hooks import use_location\n\n\n@component\ndef my_component():\n    my_location = use_location()\n    return html.div(str(my_location))\n</code></pre> See Interface <p>Parameters</p> <p><code>None</code></p> <p>Returns</p> Type Description <code>Location</code> A object containing the current URL's <code>pathname</code> and <code>search</code> query. This hook's behavior will be changed in a future update <p>This hook will be updated to return the browser's currently active path. This change will come in alongside ReactPy URL routing support.</p> <p>Check out reactive-python/reactpy-router#2 for more information.</p>"},{"location":"features/hooks/#use-origin","title":"Use Origin","text":"<p>This is a shortcut that returns the Websocket's <code>origin</code>.</p> <p>You can expect this hook to provide strings such as <code>http://example.com</code>.</p> components.py <pre><code>from reactpy import component, html\nfrom reactpy_django.hooks import use_origin\n\n\n@component\ndef my_component():\n    my_origin = use_origin()\n    return html.div(my_origin or \"No origin\")\n</code></pre> See Interface <p>Parameters</p> <p><code>None</code></p> <p>Returns</p> Type Description <code>str | None</code> A string containing the browser's current origin, obtained from websocket headers (if available)."},{"location":"features/settings/","title":"Settings","text":""},{"location":"features/settings/#overview","title":"Overview","text":"<p>  Your Django project's <code>settings.py</code> can modify the behavior of ReactPy.  </p> <p>Note</p> <p>The default configuration of ReactPy is suitable for the vast majority of use cases.</p> <p>You should only consider changing settings when the necessity arises.</p>"},{"location":"features/settings/#primary-configuration","title":"Primary Configuration","text":"<p>These are ReactPy-Django's default settings values. You can modify these values in your Django project's <code>settings.py</code> to change the behavior of ReactPy.</p> Setting Default Value Example Value(s) Description <code>REACTPY_CACHE</code> <code>\"default\"</code> <code>\"my-reactpy-cache\"</code> Cache used to store ReactPy web modules. ReactPy benefits from a fast, well indexed cache.We recommend installing <code>redis</code> or <code>python-diskcache</code>. <code>REACTPY_DATABASE</code> <code>\"default\"</code> <code>\"my-reactpy-database\"</code> Database used to store ReactPy session data. ReactPy requires a multiprocessing-safe and thread-safe database.If configuring <code>REACTPY_DATABASE</code>, it is mandatory to use our database router like such:<code>DATABASE_ROUTERS = [\"reactpy_django.database.Router\", ...]</code> <code>REACTPY_SESSION_MAX_AGE</code> <code>259200</code> <code>0</code>, <code>60</code>, <code>96000</code> Maximum seconds to store ReactPy session data, such as <code>args</code> and <code>kwargs</code> passed into your component template tag.Use <code>0</code> to not store any session data. <code>REACTPY_URL_PREFIX</code> <code>\"reactpy/\"</code> <code>\"rp/\"</code>, <code>\"render/reactpy/\"</code> The prefix to be used for all ReactPy websocket and HTTP URLs. <code>REACTPY_DEFAULT_QUERY_POSTPROCESSOR</code> <code>\"reactpy_django.utils.django_query_postprocessor\"</code> <code>\"example_project.my_query_postprocessor\"</code> Dotted path to the default <code>reactpy_django.hooks.use_query</code> postprocessor function. <code>REACTPY_AUTH_BACKEND</code> <code>\"django.contrib.auth.backends.ModelBackend\"</code> <code>\"example_project.auth.MyModelBackend\"</code> Dotted path to the Django authentication backend to use for ReactPy components. This is only needed if: 1. You are using <code>AuthMiddlewareStack</code> and... 2. You are using Django's <code>AUTHENTICATION_BACKENDS</code> setting and... 3. Your Django user model does not define a <code>backend</code> attribute. <code>REACTPY_BACKHAUL_THREAD</code> <code>False</code> <code>True</code> Whether to render ReactPy components in a dedicated thread. This allows the webserver to process web traffic while during ReactPy rendering.Vastly improves throughput with web servers such as <code>hypercorn</code> and <code>uvicorn</code>. <code>REACTPY_DEFAULT_HOSTS</code> <code>None</code> <code>[\"localhost:8000\", \"localhost:8001\", \"localhost:8002/subdir\" ]</code> The default host(s) that can render your ReactPy components. ReactPy will use these hosts in a round-robin fashion, allowing for easy distributed computing.You can use the <code>host</code> argument in your template tag as a manual override. <code>REACTPY_RECONNECT_INTERVAL</code> <code>750</code> <code>100</code>, <code>2500</code>, <code>6000</code> Milliseconds between client reconnection attempts. This value will gradually increase if <code>REACTPY_RECONNECT_BACKOFF_MULTIPLIER</code> is greater than <code>1</code>. <code>REACTPY_RECONNECT_MAX_INTERVAL</code> <code>60000</code> <code>10000</code>, <code>25000</code>, <code>900000</code> Maximum milliseconds between client reconnection attempts. This allows setting an upper bound on how high <code>REACTPY_RECONNECT_BACKOFF_MULTIPLIER</code> can increase the time between reconnection attempts. <code>REACTPY_RECONNECT_MAX_RETRIES</code> <code>150</code> <code>0</code>, <code>5</code>, <code>300</code> Maximum number of reconnection attempts before the client gives up. <code>REACTPY_RECONNECT_BACKOFF_MULTIPLIER</code> <code>1.25</code> <code>1</code>, <code>1.5</code>, <code>3</code> Multiplier for the time between client reconnection attempts. On each reconnection attempt, the <code>REACTPY_RECONNECT_INTERVAL</code> will be multiplied by this to increase the time between attempts. You can keep time between each reconnection the same by setting this to <code>1</code>."},{"location":"features/template-tag/","title":"Template Tag","text":""},{"location":"features/template-tag/#overview","title":"Overview","text":"<p>  Django template tags can be used within your HTML templates to provide ReactPy features.  </p>"},{"location":"features/template-tag/#component","title":"Component","text":"<p>The <code>component</code> template tag can be used to insert any number of ReactPy components onto your page.</p> my-template.html <pre><code>{% load reactpy %}\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;body&gt;\n{% component \"example_project.my_app.components.hello_world\" recipient=\"World\" %}\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> See Interface <p>Parameters</p> Name Type Description Default <code>dotted_path</code> <code>str</code> The dotted path to the component to render. N/A <code>*args</code> <code>Any</code> The positional arguments to provide to the component. N/A <code>class</code> <code>str | None</code> The HTML class to apply to the top-level component div. <code>None</code> <code>key</code> <code>str | None</code> Force the component's root node to use a specific key value. Using <code>key</code> within a template tag is effectively useless. <code>None</code> <code>host</code> <code>str | None</code> The host to use for the ReactPy connections. If set to <code>None</code>, the host will be automatically configured.Example values include: <code>localhost:8000</code>, <code>example.com</code>, <code>example.com/subdir</code> <code>None</code> <code>**kwargs</code> <code>Any</code> The keyword arguments to provide to the component. N/A <p>Returns</p> Type Description <code>Component</code> A ReactPy component. Do not use context variables for the ReactPy component name <p>Our preprocessor relies on the template tag containing a string.</p> <p>Do not use Django template/context variables for the component path. Failure to follow this warning can result in unexpected behavior.</p> <p>For example, do not do the following:</p> my-template.htmlviews.py <pre><code>&lt;!-- This is good --&gt;\n{% component \"example_project.my_app.components.hello_world\" recipient=\"World\" %}\n\n&lt;!-- This is bad --&gt;\n{% component dont_do_this recipient=\"World\" %}\n</code></pre> <pre><code>from django.shortcuts import render\n\n\ndef example_view(request):\n    context_vars = {\"dont_do_this\": \"example_project.my_app.components.hello_world\"}\n    return render(request, \"my-template.html\", context_vars)\n</code></pre> Can I render components on a different server (distributed computing)? <p>Yes! By using the <code>host</code> keyword argument, you can render components from a completely separate ASGI server.</p> my-template.html <pre><code>...\n{% component \"example_project.my_app.components.do_something\" host=\"127.0.0.1:8001\" %}\n...\n</code></pre> <p>This configuration most commonly involves you deploying multiple instances of your project. But, you can also create dedicated Django project(s) that only render specific ReactPy components if you wish.</p> <p>Here's a couple of things to keep in mind:</p> <ol> <li>If your host address are completely separate ( <code>origin1.com != origin2.com</code> ) you will need to configure CORS headers on your main application during deployment.</li> <li>You will not need to register ReactPy HTTP or websocket paths on any applications that do not perform any component rendering.</li> <li>Your component will only be able to access <code>*args</code>/<code>**kwargs</code> you provide to the template tag if your applications share a common database.</li> </ol> Can I use multiple components on one page? <p>You can add as many components to a webpage as needed by using the template tag multiple times. Retrofitting legacy sites to use ReactPy will typically involve many components on one page.</p> my-template.html <pre><code>{% load reactpy %}\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;body&gt;\n        &lt;h1&gt;{% component \"example_project.my_app.components.my_title\" %}&lt;/h1&gt;\n        &lt;p&gt;{% component \"example_project.my_app_2.components.goodbye_world\" class=\"bold small-font\" %}&lt;/p&gt;\n{% component \"example_project.my_app_3.components.simple_button\" %}\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Please note that components separated like this will not be able to interact with each other, except through database queries.</p> <p>Additionally, in scenarios where you are trying to create a Single Page Application (SPA) within Django, you will only have one component within your <code>&lt;body&gt;</code> tag.</p> Can I use positional arguments instead of keyword arguments? <p>You can use any combination of <code>*args</code>/<code>**kwargs</code> in your template tag.</p> my-template.htmlcomponents.py <pre><code>{% component \"example_project.my_app.components.frog_greeter\" 123 \"Mr. Froggles\" species=\"Grey Treefrog\" %}\n</code></pre> <pre><code>from reactpy import component\n\n\n@component\ndef frog_greeter(number, name, species=\"\"):\n    return f\"Hello #{number}, {name} the {species}!\"\n</code></pre>"},{"location":"features/utils/","title":"Utilities","text":""},{"location":"features/utils/#overview","title":"Overview","text":"<p>  Utility functions provide various miscellaneous functionality. These are typically not used, but are available for advanced use cases.  </p>"},{"location":"features/utils/#django-query-postprocessor","title":"Django Query Postprocessor","text":"<p>This is the default postprocessor for the <code>use_query</code> hook.</p> <p>This postprocessor is designed to avoid Django's <code>SynchronousOnlyException</code> by recursively fetching all fields within a <code>Model</code> or <code>QuerySet</code> to prevent lazy execution.</p> components.pymodels.py <pre><code>from example.models import TodoItem\nfrom reactpy import component\nfrom reactpy_django.hooks import use_query\nfrom reactpy_django.types import QueryOptions\nfrom reactpy_django.utils import django_query_postprocessor\n\n\ndef get_items():\n    return TodoItem.objects.all()\n\n\n@component\ndef todo_list():\n    # These `QueryOptions` are functionally equivalent to ReactPy-Django's default values\n    item_query = use_query(\n        QueryOptions(\n            postprocessor=django_query_postprocessor,\n            postprocessor_kwargs={\"many_to_many\": True, \"many_to_one\": True},\n        ),\n        get_items,\n    )\n\n    return item_query.data\n</code></pre> <pre><code>from django.db.models import CharField, Model\n\n\nclass TodoItem(Model):\n    text: CharField = CharField(max_length=255)\n</code></pre> See Interface <p>Parameters</p> Name Type Description Default <code>data</code> <code>QuerySet | Model</code> The <code>Model</code> or <code>QuerySet</code> to recursively fetch fields from. N/A <code>many_to_many</code> <code>bool</code> Whether or not to recursively fetch <code>ManyToManyField</code> relationships. <code>True</code> <code>many_to_one</code> <code>bool</code> Whether or not to recursively fetch <code>ForeignKey</code> relationships. <code>True</code> <p>Returns</p> Type Description <code>QuerySet | Model</code> The <code>Model</code> or <code>QuerySet</code> with all fields fetched."},{"location":"features/utils/#register-component","title":"Register Component","text":"<p>The <code>register_component</code> function is used manually register a root component with ReactPy.</p> <p>You should always call <code>register_component</code> within a Django <code>AppConfig.ready()</code> method to retain compatibility with ASGI webserver workers.</p> apps.py <pre><code>from django.apps import AppConfig\nfrom reactpy_django.utils import register_component\n\n\nclass ExampleConfig(AppConfig):\n    def ready(self):\n        # Add components to the ReactPy component registry when Django is ready\n        register_component(\"example_project.my_app.components.hello_world\")\n</code></pre> Do I need to register my components? <p>You typically will not need to use this function.</p> <p>For security reasons, ReactPy does not allow non-registered components to be root components. However, all components contained within Django templates are automatically considered root components.</p> <p>You only need to use this function if your host application does not contain any HTML templates that reference your components.</p> <p>A common scenario where this is needed is when you are modifying the template tag <code>host = ...</code> argument in order to configure a dedicated Django application as a rendering server for ReactPy. On this dedicated rendering server, you would need to manually register your components.</p>"},{"location":"get-started/choose-django-app/","title":"Choose a Django App","text":""},{"location":"get-started/choose-django-app/#overview","title":"Overview","text":"<p>  Set up a Django Project with at least one app.  </p> <p>Note</p> <p>If you have reached this point, you should have already installed ReactPy-Django through the previous steps.</p>"},{"location":"get-started/choose-django-app/#deciding-which-django-app-to-use","title":"Deciding which Django App to use","text":"<p>You will now need to pick at least one Django app to start using ReactPy-Django on.</p> <p>For the following examples, we will assume the following:</p> <ol> <li>You have a Django app named <code>my_app</code>, which was created by Django's <code>startapp</code> command.</li> <li>You have placed <code>my_app</code> directly into your Django project folder (<code>./example_project/my_app</code>). This is common for small projects.</li> </ol> How do I organize my Django project for ReactPy? <p>ReactPy-Django has no project structure requirements. Organize everything as you wish, just like any Django project.</p>"},{"location":"get-started/create-component/","title":"Create a Component","text":""},{"location":"get-started/create-component/#overview","title":"Overview","text":"<p>  You can let ReactPy know what functions are components by using the <code>@component</code> decorator.  </p>"},{"location":"get-started/create-component/#declaring-a-function-as-a-root-component","title":"Declaring a function as a root component","text":"<p>You will need a file to start creating ReactPy components.</p> <p>We recommend creating a <code>components.py</code> file within your chosen Django app to start out. For this example, the file path will look like this: <code>./example_project/my_app/components.py</code>.</p> <p>Within this file, you can define your component functions and then add ReactPy's <code>@component</code> decorator.</p> components.py <pre><code>from reactpy import component, html\n\n@component\ndef hello_world(recipient: str):\n    return html.h1(f\"Hello {recipient}!\")\n</code></pre> What should I name my ReactPy files and functions? <p>You have full freedom in naming/placement of your files and functions.</p> <p>We recommend creating a <code>components.py</code> for small Django apps. If your app has a lot of components, you should consider breaking them apart into individual modules such as <code>components/navbar.py</code>.</p> <p>Ultimately, components are referenced by Python dotted path in <code>my-template.html</code> (see next step). So, at minimum your component path needs to be valid to Python's <code>importlib</code>.</p> What does the decorator actually do? <p>While not all components need to be decorated, there are a few features this decorator adds to your components.</p> <ol> <li>The ability to be used as a root component.<ul> <li>The decorator is required for any component that you want to reference in your Django templates (see next step).</li> </ul> </li> <li>The ability to use hooks.<ul> <li>The decorator is required on any component where hooks are defined.</li> </ul> </li> <li>Scoped failures.<ul> <li>If a decorated component generates an exception, then only that one component will fail to render.</li> </ul> </li> </ol>"},{"location":"get-started/installation/","title":"Install ReactPy-Django","text":""},{"location":"get-started/installation/#overview","title":"Overview","text":"<p> ReactPy-Django can be used to add used to add ReactPy support to an existing Django project. Minimal configuration is required to get started.  </p> <p>Note</p> <p>These docs assumes you have already created a Django project, which involves creating and installing at least one Django app.</p> <p>If do not have a Django project, check out this 9 minute YouTube tutorial created by IDG TECHtalk.</p>"},{"location":"get-started/installation/#step-1-install-from-pypi","title":"Step 1: Install from PyPI","text":"<pre><code>pip install reactpy-django\n</code></pre>"},{"location":"get-started/installation/#step-2-configure-settingspy","title":"Step 2: Configure <code>settings.py</code>","text":"<p>In your settings you will need to add <code>reactpy_django</code> to <code>INSTALLED_APPS</code>.</p> settings.py <pre><code>INSTALLED_APPS = [\n    ...,\n    \"reactpy_django\",\n]\n</code></pre> Enable Django Channels ASGI (Required) <p>ReactPy-Django requires ASGI Websockets from Django Channels.</p> <p>If you have not enabled ASGI on your Django project yet, you will need to</p> <ol> <li>Install <code>channels[daphne]</code></li> <li>Add <code>daphne</code> to <code>INSTALLED_APPS</code></li> <li>Set your <code>ASGI_APPLICATION</code> variable.</li> </ol> settings.py <pre><code>INSTALLED_APPS = [\n    \"daphne\",\n    ...,\n]\nASGI_APPLICATION = \"example_project.asgi.application\"\n</code></pre> <p>Consider reading the Django Channels Docs for more info.</p> Configure ReactPy settings (Optional) <p>These are ReactPy-Django's default settings values. You can modify these values in your Django project's <code>settings.py</code> to change the behavior of ReactPy.</p> Setting Default Value Example Value(s) Description <code>REACTPY_CACHE</code> <code>\"default\"</code> <code>\"my-reactpy-cache\"</code> Cache used to store ReactPy web modules. ReactPy benefits from a fast, well indexed cache.We recommend installing <code>redis</code> or <code>python-diskcache</code>. <code>REACTPY_DATABASE</code> <code>\"default\"</code> <code>\"my-reactpy-database\"</code> Database used to store ReactPy session data. ReactPy requires a multiprocessing-safe and thread-safe database.If configuring <code>REACTPY_DATABASE</code>, it is mandatory to use our database router like such:<code>DATABASE_ROUTERS = [\"reactpy_django.database.Router\", ...]</code> <code>REACTPY_SESSION_MAX_AGE</code> <code>259200</code> <code>0</code>, <code>60</code>, <code>96000</code> Maximum seconds to store ReactPy session data, such as <code>args</code> and <code>kwargs</code> passed into your component template tag.Use <code>0</code> to not store any session data. <code>REACTPY_URL_PREFIX</code> <code>\"reactpy/\"</code> <code>\"rp/\"</code>, <code>\"render/reactpy/\"</code> The prefix to be used for all ReactPy websocket and HTTP URLs. <code>REACTPY_DEFAULT_QUERY_POSTPROCESSOR</code> <code>\"reactpy_django.utils.django_query_postprocessor\"</code> <code>\"example_project.my_query_postprocessor\"</code> Dotted path to the default <code>reactpy_django.hooks.use_query</code> postprocessor function. <code>REACTPY_AUTH_BACKEND</code> <code>\"django.contrib.auth.backends.ModelBackend\"</code> <code>\"example_project.auth.MyModelBackend\"</code> Dotted path to the Django authentication backend to use for ReactPy components. This is only needed if: 1. You are using <code>AuthMiddlewareStack</code> and... 2. You are using Django's <code>AUTHENTICATION_BACKENDS</code> setting and... 3. Your Django user model does not define a <code>backend</code> attribute. <code>REACTPY_BACKHAUL_THREAD</code> <code>False</code> <code>True</code> Whether to render ReactPy components in a dedicated thread. This allows the webserver to process web traffic while during ReactPy rendering.Vastly improves throughput with web servers such as <code>hypercorn</code> and <code>uvicorn</code>. <code>REACTPY_DEFAULT_HOSTS</code> <code>None</code> <code>[\"localhost:8000\", \"localhost:8001\", \"localhost:8002/subdir\" ]</code> The default host(s) that can render your ReactPy components. ReactPy will use these hosts in a round-robin fashion, allowing for easy distributed computing.You can use the <code>host</code> argument in your template tag as a manual override. <code>REACTPY_RECONNECT_INTERVAL</code> <code>750</code> <code>100</code>, <code>2500</code>, <code>6000</code> Milliseconds between client reconnection attempts. This value will gradually increase if <code>REACTPY_RECONNECT_BACKOFF_MULTIPLIER</code> is greater than <code>1</code>. <code>REACTPY_RECONNECT_MAX_INTERVAL</code> <code>60000</code> <code>10000</code>, <code>25000</code>, <code>900000</code> Maximum milliseconds between client reconnection attempts. This allows setting an upper bound on how high <code>REACTPY_RECONNECT_BACKOFF_MULTIPLIER</code> can increase the time between reconnection attempts. <code>REACTPY_RECONNECT_MAX_RETRIES</code> <code>150</code> <code>0</code>, <code>5</code>, <code>300</code> Maximum number of reconnection attempts before the client gives up. <code>REACTPY_RECONNECT_BACKOFF_MULTIPLIER</code> <code>1.25</code> <code>1</code>, <code>1.5</code>, <code>3</code> Multiplier for the time between client reconnection attempts. On each reconnection attempt, the <code>REACTPY_RECONNECT_INTERVAL</code> will be multiplied by this to increase the time between attempts. You can keep time between each reconnection the same by setting this to <code>1</code>."},{"location":"get-started/installation/#step-3-configure-urlspy","title":"Step 3: Configure <code>urls.py</code>","text":"<p>Add ReactPy HTTP paths to your <code>urlpatterns</code>.</p> urls.py <pre><code>from django.urls import include, path\n\nurlpatterns = [\n    ...,\n    path(\"reactpy/\", include(\"reactpy_django.http.urls\")),\n]\n</code></pre>"},{"location":"get-started/installation/#step-4-configure-asgipy","title":"Step 4: Configure <code>asgi.py</code>","text":"<p>Register ReactPy's Websocket using <code>REACTPY_WEBSOCKET_ROUTE</code>.</p> asgi.py <pre><code>import os\n\nfrom django.core.asgi import get_asgi_application\n\n# Ensure DJANGO_SETTINGS_MODULE is set properly based on your project name!\nos.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"example_project.settings\")\n\n# Fetch ASGI application before importing dependencies that require ORM models.\ndjango_asgi_app = get_asgi_application()\n\n\nfrom channels.routing import ProtocolTypeRouter, URLRouter  # noqa: E402\nfrom reactpy_django import REACTPY_WEBSOCKET_ROUTE  # noqa: E402\n\napplication = ProtocolTypeRouter(\n    {\n        \"http\": django_asgi_app,\n        \"websocket\": URLRouter([REACTPY_WEBSOCKET_ROUTE]),\n    }\n)\n</code></pre> Add <code>AuthMiddlewareStack</code> and <code>SessionMiddlewareStack</code> (Optional) <p>There are many situations where you need to access the Django <code>User</code> or <code>Session</code> objects within ReactPy components. For example, if you want to:</p> <ol> <li>Access the <code>User</code> that is currently logged in</li> <li>Login or logout the current <code>User</code></li> <li>Access Django's <code>Session</code> object</li> </ol> <p>In these situations will need to ensure you are using <code>AuthMiddlewareStack</code> and/or <code>SessionMiddlewareStack</code>.</p> <pre><code>from channels.auth import AuthMiddlewareStack  # noqa: E402\nfrom channels.sessions import SessionMiddlewareStack  # noqa: E402\n\napplication = ProtocolTypeRouter(\n    {\n        \"http\": django_asgi_app,\n        \"websocket\": SessionMiddlewareStack(\n            AuthMiddlewareStack(\n                URLRouter(\n                    [REACTPY_WEBSOCKET_ROUTE],\n                )\n            )\n        ),\n    }\n)\n</code></pre> Where is my <code>asgi.py</code>? <p>If you do not have an <code>asgi.py</code>, follow the <code>channels</code> installation guide.</p>"},{"location":"get-started/installation/#step-5-run-database-migrations","title":"Step 5: Run database migrations","text":"<p>Run Django's database migrations to initialize ReactPy-Django's database table.</p> <pre><code>python manage.py migrate\n</code></pre>"},{"location":"get-started/installation/#step-6-check-your-configuration","title":"Step 6: Check your configuration","text":"<p>Run Django's check command to verify if ReactPy was set up correctly.</p> <pre><code>python manage.py check\n</code></pre>"},{"location":"get-started/installation/#step-7-create-your-first-component","title":"Step 7: Create your first component!","text":"<p>The following steps will show you how to create your first ReactPy component.</p> <p>Prefer a quick summary? Read the At a Glance section below.</p> <p>At a Glance</p> <p><code>my_app/components.py</code></p> <p>You will need a file to define your ReactPy components. We recommend creating a <code>components.py</code> file within your chosen Django app to start out. Within this file, we will create a simple <code>hello_world</code> component.</p> <p> </p> <pre><code>from reactpy import component, html\n\n@component\ndef hello_world(recipient: str):\n    return html.h1(f\"Hello {recipient}!\")\n</code></pre> <p><code>my_app/templates/my-template.html</code></p> <p>In your Django app's HTML template, you can now embed your ReactPy component using the <code>component</code> template tag. Within this tag, you will need to type in the dotted path to the component.</p> <p>Additionally, you can pass in <code>args</code> and <code>kwargs</code> into your component function. After reading the code below, pay attention to how the function definition for <code>hello_world</code> (from the previous example) accepts a <code>recipient</code> argument.</p> <pre><code>{% load reactpy %}\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;body&gt;\n{% component \"example_project.my_app.components.hello_world\" recipient=\"World\" %}\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"get-started/learn-more/","title":"Congratulations","text":"<p>  If you followed the previous steps, you have now created a \"Hello World\" component using ReactPy-Django!  </p> <p>Deep Dive</p> <p>The docs you are reading only covers our Django integration. To learn more, check out one of the following links:</p> <ul> <li>ReactPy-Django Feature Reference</li> <li>ReactPy Core Documentation</li> <li>Ask Questions on Discord</li> </ul> <p>Additionally, the vast majority of tutorials/guides you find for ReactJS can be applied to ReactPy.</p>"},{"location":"get-started/register-view/","title":"Register a View","text":""},{"location":"get-started/register-view/#overview","title":"Overview","text":"<p>  Render your template containing your ReactPy component using a Django view.  </p> <p>Note</p> <p>We assume you have created a Django View before, but we have included a simple example below.</p>"},{"location":"get-started/register-view/#creating-a-django-view-and-url-path","title":"Creating a Django view and URL path","text":"<p>Within your Django app's <code>views.py</code> file, you will need to create a function to render the HTML template containing your ReactPy components.</p> <p>In this example, we will create a view that renders <code>my-template.html</code> (from the previous step).</p> views.py <pre><code>from django.shortcuts import render\n\n\ndef index(request):\n    return render(request, \"my-template.html\")\n</code></pre> <p>We will add this new view into your <code>urls.py</code>.</p> urls.py <pre><code>from django.urls import path\nfrom example import views\n\nurlpatterns = [\n    path(\"example/\", views.index),\n]\n</code></pre> Which urls.py do I add my views to? <p>For simple Django projects, you can easily add all of your views directly into the Django project's <code>urls.py</code>. However, as you start increase your project's complexity you might end up with way too much within one file.</p> <p>Once you reach that point, we recommend creating an individual <code>urls.py</code> within each of your Django apps.</p> <p>Then, within your Django project's <code>urls.py</code> you will use Django's <code>include</code> function to link it all together.</p>"},{"location":"get-started/run-webserver/","title":"Run the Webserver","text":""},{"location":"get-started/run-webserver/#overview","title":"Overview","text":"<p>  Run a webserver to display your Django view.  </p>"},{"location":"get-started/run-webserver/#viewing-your-component-using-a-webserver","title":"Viewing your component using a webserver","text":"<p>To test your new Django view, run the following command to start up a development webserver.</p> <pre><code>python manage.py runserver\n</code></pre> <p>Now you can navigate to your Django project URL that contains a ReactPy component, such as <code>http://127.0.0.1:8000/example/</code> (from the previous step).</p> <p>If you copy-pasted our example component, you will now see your component display \"Hello World\".</p> <p>Pitfall</p> <p>Do not use <code>manage.py runserver</code> for production.</p> <p>This command is only intended for development purposes. For production deployments make sure to read Django's documentation.</p>"},{"location":"get-started/use-template-tag/","title":"Use the Template Tag","text":""},{"location":"get-started/use-template-tag/#overview","title":"Overview","text":"<p>  Decide where the component will be displayed by using our template tag.  </p>"},{"location":"get-started/use-template-tag/#embedding-a-component-in-a-template","title":"Embedding a component in a template","text":"<p>In your Django app's HTML template, you can now embed your ReactPy component using the <code>component</code> template tag. Within this tag, you will need to type in the dotted path to the component.</p> <p>Additionally, you can pass in <code>args</code> and <code>kwargs</code> into your component function. After reading the code below, pay attention to how the function definition for <code>hello_world</code> (from the previous step) accepts a <code>recipient</code> argument.</p> my-template.html <pre><code>{% load reactpy %}\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;body&gt;\n{% component \"example_project.my_app.components.hello_world\" recipient=\"World\" %}\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> Do not use context variables for the ReactPy component name <p>Our preprocessor relies on the template tag containing a string.</p> <p>Do not use Django template/context variables for the component path. Failure to follow this warning can result in unexpected behavior.</p> <p>For example, do not do the following:</p> my-template.htmlviews.py <pre><code>&lt;!-- This is good --&gt;\n{% component \"example_project.my_app.components.hello_world\" recipient=\"World\" %}\n\n&lt;!-- This is bad --&gt;\n{% component dont_do_this recipient=\"World\" %}\n</code></pre> <pre><code>from django.shortcuts import render\n\n\ndef example_view(request):\n    context_vars = {\"dont_do_this\": \"example_project.my_app.components.hello_world\"}\n    return render(request, \"my-template.html\", context_vars)\n</code></pre> Can I use multiple components on one page? <p>You can add as many components to a webpage as needed by using the template tag multiple times. Retrofitting legacy sites to use ReactPy will typically involve many components on one page.</p> my-template.html <pre><code>{% load reactpy %}\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;body&gt;\n        &lt;h1&gt;{% component \"example_project.my_app.components.my_title\" %}&lt;/h1&gt;\n        &lt;p&gt;{% component \"example_project.my_app_2.components.goodbye_world\" class=\"bold small-font\" %}&lt;/p&gt;\n{% component \"example_project.my_app_3.components.simple_button\" %}\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Please note that components separated like this will not be able to interact with each other, except through database queries.</p> <p>Additionally, in scenarios where you are trying to create a Single Page Application (SPA) within Django, you will only have one component within your <code>&lt;body&gt;</code> tag.</p> Where is my templates folder? <p>If you do not have a <code>templates</code> folder in your Django app, you can simply create one! Keep in mind, templates within this folder will not be detected by Django unless you add the corresponding Django app to <code>settings.py:INSTALLED_APPS</code>.</p>"}]}